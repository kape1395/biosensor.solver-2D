@author Karolis Petrauskas <k.petrauskas@gmail.com>
@copyright 2012 Karolis Petrauskas
@version 0.7.0
@title Erlang Server for Simulating Biosensors (bio_ers | {ebs, ebi})
@doc

== Introduction ==

This is an Erlang application supposed to manage execution of multiple
simulations. The name `bio_ers' stands for "Biosensor (bio) simulation
Erlang (er) Server (s)". The server should support:
<ul>
  <li>
    Queue simulation jobs and execute them. The queue should allow to
    manage concurency and therefore increase speed of simulations.
  </li><li>
    Allow the simulations to be paused and resumed in a convenient way,
    support simulation management in cases of machine restarts.
  </li><li>
    Provide convenient way to express parameter variation problems.
  </li><li>
    Help to manage calculation on multiple machines. Migration of
    running simulations should be supported also.
  </li><li>
    Maybe to help submitting jobs to a grid.
  </li>
</ul>

Main data structures are described in the {@link bio_ers} module.


== Design decisions ==

This section states main design decisions, made when developing bio_ers.
The list is to not forget and follow them. Updates to the principles are
of coutse allowed, just changes must be documented here including
argumentation for the changes. As for today the decisions are the following:
<ul>
  <li>
    Implement process pool (simulation job queue). No maintained embedable
    implementation was found.
    TBD: Add known references here.
  </li><li>
    Use EI (Erlang Interface) to implement biosensor solver port [ei1, ei2].
    Maybe its better to not invent own protocol. Note that EI replaces
    mostly deprecated erl_interface [ei3]. The biosensor solver port
    implementation is in ../bio_ers_solver_port/.
  </li><li>
    Use SHA1 of the experiment definition for its identification. The
    approach whould be similar to one used in GIT. The model and sorted
    set of its parameters could be used for the hashing.
  </li><li>
    Use Mnesia DB for storing data in run (simulation) time. Filesystem and
    simple file formats (CSV, etc) should be used for storing data for long
    term (archiving). Model definitions can be stored opaque, in the format
    used to run simulations directly (for the traceability). Export from the
    Mnesia DB to the external format should be implemented.
  </li><li>
  ? Transformation of a model to a atructure of primitive solver components
    should be done in erlang. I am expecting to have cleaner code in this way.
    Another aspect is that C++ side should be rewritten anyway to employ
    IoC pattern instead of heavy constructors where appropriate.
  </li>
</ul>


== Dependencies ==

Used modules:
<ul>
  <li>xmerl_scan</li>
  <li>eunit</li>
</ul>


== Simulation output ==

All the output generated by the solver is stored in the file system.
While the simulation is not completed yet, its output is stored in
the temporary folder. After the simulation was completed, its data
is moved to the separate folder.

It was decided to use the file system for storing output of the
simulations mainly because of performance aspects.
Only references to the corresponding files will be stored
in the Mnesia data base. 


== Simulation checkpoints ==

Checkpoints are used to support simulation restarts and rollbacks.
The checkpoints are requested by the Erlang processes (usually {@link bio_ers_solver})
and generated by the external solver process.
When the solver receives the request to create the checkpoint,
it sends a message back to the port's connected process containing
all the data needed to restore the simulation to the identical situation.

When making the checkpoint, the solver flushes all the output
streams and record the current stream positions (using `std::ostream::tellp()').
References to the output files along with the stream positions are then
sent to the Erlang process ({@link bio_ers_solver}).
Apart from the output files, current concentrations of species should be
saved as well as all the internal state of the attached listeners.
Both of them are sent to the Erlang in the
{@link bio_ers_solver:port_checkpoint(). port_checkpoint} message directly.
Such approach was considered expecting that it should be easier
to maintain the checkpoints and higher precision will be maintained when
storing concentrations (because of 64-bit IEEE format for floats when the
`{minor_version, 1}' option is set for the `erlang:term_to_binary/2').


== References ==
[ei1] http://www.erlang.org/doc/apps/erl_interface/users_guide.html<br/>
[ei2] http://www.erlang.org/doc/man/ei.html<br/>
[ei3] http://www.erlang.org/faq/how_do_i.html<br/>
[?ei4] http://kazmier.net/computer/port-howto/<br/>
[?ei5] http://www.erlang.org/doc/apps/erts/erl_ext_dist.html<br/>
[?dev1] http://www.erlang.se/doc/programming_rules.shtml<br/>
[?dev2] http://wwwhome.cs.utwente.nl/~tcm/index.html<br/>
[?dev3] http://www.erlang.org/doc/apps/tools/erlang_mode_chapter.html<br/>
[?tst1] http://erlymock-site.sourceforge.net/<br/>
[?tst2] http://stackoverflow.com/questions/1202539/how-do-i-do-dependency-injection-and-mocks-in-erlang<br/>
[?doc1] http://www.erlang.org/doc/man/edoc.html<br/>
[?doc2] https://support.process-one.net/doc/display/ERL/Documenting+your+code+and+generating+the+Erlang+code+documentation<br/>
[ssh1] http://www.erlang.org/doc/man/ssh.html<br/>
[ssh2] http://easyerl.blogspot.com/2007/11/experimenting-with-erlang-ssh-support.html<br/>
[ssh3] https://github.com/jj1bdx/sshrpc/<br/>


== Appendix A. ==

Some useful commands for a developer:
```
    erl -pa ebin -s bio_ers_app startup
        application:which_applications().   # List running apps.
        eunit:test(bio_ers).                # Run unit tests.
        rr(xmerl).                          # Load record definitions.
        rp([list, {a}]).                    # Prints all the structure recursivelly
        i().                                # Lists processes.
        pman:start().                       # Process manager (GUI).
        appmon:start().                     # Application manager (GUI).
        init:stop().                        # Quit.

    erl -env ERL_LIBS .                     # TODO: Versions should be respected here.
        systools:make_script("bio_ers", [local, no_warn_sasl]).
        systools:make_tar("bio_ers").

    make test_run   # For the change-compile-check loop...
        rp({os:cmd("make"), code:purge(bio_ers_model), code:load_file(bio_ers_model)}).
        rp(bio_ers_model:parse_file("test/bio_ers_model_tests-CNT-2D.xml")).

    make check      # Runs all the unit tests.
'''


== Appendix B. ==

SSH connection to the MIF PST can be implemented using erlang's ssh module [ssh1].
The following is a working code, writen using an example [ssh2]:
```
    application:start(crypto).
    application:start(ssh).
    {ok, CR} = ssh:connect("uosis.mif.vu.lt", 22, [{user_dir, "/home/karolis/.ssh"}, {user, "karolis"}, {silently_accept_hosts, true}]).
    {ok, CH} = ssh_connection:session_channel(CR, 5000).
    receive R1 -> rp(R1) after 1000 -> timeout end.
    ok = ssh_connection:shell(CR, CH).
    receive R2 -> rp(R2) after 1000 -> timeout end.
    X2 = ssh_connection:send(CR, CH, "pwd\n").
    receive R3 -> rp(R3) after 1000 -> timeout end.
    receive R4 -> rp(R4) after 1000 -> timeout end.
    receive R5 -> rp(R5) after 1000 -> timeout end.
    receive R6 -> rp(R6) after 1000 -> timeout end.
    ok = ssh_connection:close(CR, CH).
    ok = ssh:close(CR).
'''

It looks reasonable to do the SSH communication by implementing ssh_channel
module (callbacks) [ssh3].

