                      Biosensor Simulation Erlang Server
                                    bio_ers

Introduction
============
This is an Erlang application supposed to manage execution of multiple
simulations. The name `bio_ers' stands for "Biosensor (bio) simulation
Erlang (er) Server (s)". The server should support:
  * Queue simulation jobs and execute them. The queue should allow to
    manage concurency and therefore increase speed of simulations.
  * Allow the simulations to be paused and resumed in a convenient way,
    support simulation management in cases of machine restarts.
  * Provide convenient way to express parameter variation problems.
  * Help to manage calculation on multiple machines. Migration of
    running simulations should be supported also.
  * Maybe to help submitting jobs to a grid.


Design decisions
================
This section states main design decisions, made when developing bio_ers.
The list is to not forget and follow them. Updates to the principles are
of coutse allowed, just changes must be documented here including
argumentation for the changes. As for today the decisions are the following:
  * Implement process pool (simulation job queue). No maintained embedable
    implementation was found.
    TODO: Add known references here.
  * Use EI (Erlang Interface) to implement biosensor solver port [ei1, ei2].
    Maybe its better to not invent own protocol. Note that EI replaces
    mostly deprecated erl_interface [ei3]. The biosensor solver port
    implementation is in ../bio_ers_solver_port/.
  * Use SHA1 of the experiment definition for its identification. The
    approach whould be similar to one used in GIT. The model and sorted
    set of its parameters could be used for the hashing.
  * Use Mnesia DB for storing data in run (simulation) time. Filesystem and
    simple file formats (CSV, etc) should be used for storing data for long
    term (archiving). Model definitions can be stored opaque, in the format
    used to run simulations directly (for the traceability). Export from the
    Mnesia DB to the external format should be implemented.
  ? Transformation of a model to a atructure of primitive solver components
    should be done in erlang. I am expecting to have cleaner code in this way.
    Another aspect is that C++ side should be rewritten anyway to employ
    IoC pattern instead of heavy constructors where appropriate.


Dependencies
============
Used modules:
  * xmerl_scan
  * eunit


References
==========
[ei1] http://www.erlang.org/doc/apps/erl_interface/users_guide.html
[ei2] http://www.erlang.org/doc/man/ei.html
[ei3] http://www.erlang.org/faq/how_do_i.html
[?ei4] http://kazmier.net/computer/port-howto/
[?ei5] http://www.erlang.org/doc/apps/erts/erl_ext_dist.html
[?dev1] http://www.erlang.se/doc/programming_rules.shtml
[?dev2] http://wwwhome.cs.utwente.nl/~tcm/index.html
[?dev3] http://www.erlang.org/doc/apps/tools/erlang_mode_chapter.html
[?tst1] http://erlymock-site.sourceforge.net/
[?tst2] http://stackoverflow.com/questions/1202539/how-do-i-do-dependency-injection-and-mocks-in-erlang
[?doc1] http://www.erlang.org/doc/man/edoc.html
[?doc2] https://support.process-one.net/doc/display/ERL/Documenting+your+code+and+generating+the+Erlang+code+documentation
[ssh1] http://www.erlang.org/doc/man/ssh.html
[ssh2] http://easyerl.blogspot.com/2007/11/experimenting-with-erlang-ssh-support.html
[ssh3] https://github.com/jj1bdx/sshrpc/


Appendix A.
===========
Some useful commands for a developer:
    erl -pa ebin -s bio_ers_app startup
        application:which_applications().   # List running apps.
        eunit:test(bio_ers).                # Run unit tests.
        rr(xmerl).                          # Load record definitions.
        rp([list, {a}]).                    # Prints all the structure recursivelly
        i().                                # Lists processes.
        pman:start().                       # Process manager (GUI).
        appmon:start().                     # Application manager (GUI).
        init:stop().                        # Quit.

    erl -env ERL_LIBS .                     # TODO: Versions should be respected here.
        systools:make_script("bio_ers", [local, no_warn_sasl]).
        systools:make_tar("bio_ers").

    make test_run   # For the change-compile-check loop...
        rp({os:cmd("make"), code:purge(bio_ers_model), code:load_file(bio_ers_model)}).
        rp(bio_ers_model:parse_file("test/bio_ers_model_tests-CNT-2D.xml")).

    make check      # Runs all the unit tests.

Appendix B.
===========
SSH connection to the MIF PST can be implemented using erlang's ssh module [ssh1].
The following is a working code, writen using an example [ssh2]:
    application:start(crypto).
    application:start(ssh).
    {ok, CR} = ssh:connect("uosis.mif.vu.lt", 22, [{user_dir, "/home/karolis/.ssh"}, {user, "karolis"}, {silently_accept_hosts, true}]).
    {ok, CH} = ssh_connection:session_channel(CR, 5000).
    receive R1 -> rp(R1) after 1000 -> timeout end.
    ok = ssh_connection:shell(CR, CH).
    receive R2 -> rp(R2) after 1000 -> timeout end.
    X2 = ssh_connection:send(CR, CH, "pwd\n").
    receive R3 -> rp(R3) after 1000 -> timeout end.
    receive R4 -> rp(R4) after 1000 -> timeout end.
    receive R5 -> rp(R5) after 1000 -> timeout end.
    receive R6 -> rp(R6) after 1000 -> timeout end.
    ok = ssh_connection:close(CR, CH).
    ok = ssh:close(CR).

It looks reasonable to do the SSH communication by implementing ssh_channel
module (callbacks) [ssh3].
