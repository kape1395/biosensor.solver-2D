// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Model.hxx"

namespace bio
{
  namespace xml
  {
    namespace model
    {
      // Model
      // 

      const Model::axis_sequence& Model::
      axis () const
      {
        return this->axis_;
      }

      Model::axis_sequence& Model::
      axis ()
      {
        return this->axis_;
      }

      void Model::
      axis (const axis_sequence& axis)
      {
        this->axis_ = axis;
      }

      const Model::substance_sequence& Model::
      substance () const
      {
        return this->substance_;
      }

      Model::substance_sequence& Model::
      substance ()
      {
        return this->substance_;
      }

      void Model::
      substance (const substance_sequence& substance)
      {
        this->substance_ = substance;
      }

      const Model::medium_sequence& Model::
      medium () const
      {
        return this->medium_;
      }

      Model::medium_sequence& Model::
      medium ()
      {
        return this->medium_;
      }

      void Model::
      medium (const medium_sequence& medium)
      {
        this->medium_ = medium;
      }

      const Model::bound_sequence& Model::
      bound () const
      {
        return this->bound_;
      }

      Model::bound_sequence& Model::
      bound ()
      {
        return this->bound_;
      }

      void Model::
      bound (const bound_sequence& bound)
      {
        this->bound_ = bound;
      }

      const Model::transducer_optional& Model::
      transducer () const
      {
        return this->transducer_;
      }

      Model::transducer_optional& Model::
      transducer ()
      {
        return this->transducer_;
      }

      void Model::
      transducer (const transducer_type& transducer)
      {
        this->transducer_.set (transducer);
      }

      void Model::
      transducer (const transducer_optional& transducer)
      {
        this->transducer_ = transducer;
      }

      void Model::
      transducer (::std::auto_ptr< transducer_type > transducer)
      {
        this->transducer_.set (transducer);
      }

      const Model::symbol_sequence& Model::
      symbol () const
      {
        return this->symbol_;
      }

      Model::symbol_sequence& Model::
      symbol ()
      {
        return this->symbol_;
      }

      void Model::
      symbol (const symbol_sequence& symbol)
      {
        this->symbol_ = symbol;
      }

      const Model::solver_type& Model::
      solver () const
      {
        return this->solver_.get ();
      }

      Model::solver_type& Model::
      solver ()
      {
        return this->solver_.get ();
      }

      void Model::
      solver (const solver_type& solver)
      {
        this->solver_.set (solver);
      }

      void Model::
      solver (::std::auto_ptr< solver_type > solver)
      {
        this->solver_.set (solver);
      }

      const Model::coordinateSystem_type& Model::
      coordinateSystem () const
      {
        return this->coordinateSystem_.get ();
      }

      Model::coordinateSystem_type& Model::
      coordinateSystem ()
      {
        return this->coordinateSystem_.get ();
      }

      void Model::
      coordinateSystem (const coordinateSystem_type& coordinateSystem)
      {
        this->coordinateSystem_.set (coordinateSystem);
      }

      void Model::
      coordinateSystem (::std::auto_ptr< coordinateSystem_type > coordinateSystem)
      {
        this->coordinateSystem_.set (coordinateSystem);
      }


      // Axis
      // 

      const Axis::point_sequence& Axis::
      point () const
      {
        return this->point_;
      }

      Axis::point_sequence& Axis::
      point ()
      {
        return this->point_;
      }

      void Axis::
      point (const point_sequence& point)
      {
        this->point_ = point;
      }

      const Axis::name_type& Axis::
      name () const
      {
        return this->name_.get ();
      }

      Axis::name_type& Axis::
      name ()
      {
        return this->name_.get ();
      }

      void Axis::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void Axis::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }


      // AxisPoint
      // 

      const AxisPoint::position_type& AxisPoint::
      position () const
      {
        return this->position_.get ();
      }

      AxisPoint::position_type& AxisPoint::
      position ()
      {
        return this->position_.get ();
      }

      void AxisPoint::
      position (const position_type& position)
      {
        this->position_.set (position);
      }

      void AxisPoint::
      position (::std::auto_ptr< position_type > position)
      {
        this->position_.set (position);
      }


      // Substance
      // 

      const Substance::name_type& Substance::
      name () const
      {
        return this->name_.get ();
      }

      Substance::name_type& Substance::
      name ()
      {
        return this->name_.get ();
      }

      void Substance::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void Substance::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }


      // Medium
      // 

      const Medium::substance_sequence& Medium::
      substance () const
      {
        return this->substance_;
      }

      Medium::substance_sequence& Medium::
      substance ()
      {
        return this->substance_;
      }

      void Medium::
      substance (const substance_sequence& substance)
      {
        this->substance_ = substance;
      }

      const Medium::reaction_sequence& Medium::
      reaction () const
      {
        return this->reaction_;
      }

      Medium::reaction_sequence& Medium::
      reaction ()
      {
        return this->reaction_;
      }

      void Medium::
      reaction (const reaction_sequence& reaction)
      {
        this->reaction_ = reaction;
      }

      const Medium::area_sequence& Medium::
      area () const
      {
        return this->area_;
      }

      Medium::area_sequence& Medium::
      area ()
      {
        return this->area_;
      }

      void Medium::
      area (const area_sequence& area)
      {
        this->area_ = area;
      }

      const Medium::name_type& Medium::
      name () const
      {
        return this->name_.get ();
      }

      Medium::name_type& Medium::
      name ()
      {
        return this->name_.get ();
      }

      void Medium::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void Medium::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }


      // MediumSubstance
      // 

      const MediumSubstance::name_type& MediumSubstance::
      name () const
      {
        return this->name_.get ();
      }

      MediumSubstance::name_type& MediumSubstance::
      name ()
      {
        return this->name_.get ();
      }

      void MediumSubstance::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void MediumSubstance::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }

      const MediumSubstance::diffusion_optional& MediumSubstance::
      diffusion () const
      {
        return this->diffusion_;
      }

      MediumSubstance::diffusion_optional& MediumSubstance::
      diffusion ()
      {
        return this->diffusion_;
      }

      void MediumSubstance::
      diffusion (const diffusion_type& diffusion)
      {
        this->diffusion_.set (diffusion);
      }

      void MediumSubstance::
      diffusion (const diffusion_optional& diffusion)
      {
        this->diffusion_ = diffusion;
      }

      void MediumSubstance::
      diffusion (::std::auto_ptr< diffusion_type > diffusion)
      {
        this->diffusion_.set (diffusion);
      }

      const MediumSubstance::initial_type& MediumSubstance::
      initial () const
      {
        return this->initial_.get ();
      }

      MediumSubstance::initial_type& MediumSubstance::
      initial ()
      {
        return this->initial_.get ();
      }

      void MediumSubstance::
      initial (const initial_type& initial)
      {
        this->initial_.set (initial);
      }

      void MediumSubstance::
      initial (::std::auto_ptr< initial_type > initial)
      {
        this->initial_.set (initial);
      }


      // MediumReaction
      // 


      // MediumArea
      // 

      const MediumArea::top_optional& MediumArea::
      top () const
      {
        return this->top_;
      }

      MediumArea::top_optional& MediumArea::
      top ()
      {
        return this->top_;
      }

      void MediumArea::
      top (const top_type& top)
      {
        this->top_.set (top);
      }

      void MediumArea::
      top (const top_optional& top)
      {
        this->top_ = top;
      }

      void MediumArea::
      top (::std::auto_ptr< top_type > top)
      {
        this->top_.set (top);
      }

      const MediumArea::bottom_optional& MediumArea::
      bottom () const
      {
        return this->bottom_;
      }

      MediumArea::bottom_optional& MediumArea::
      bottom ()
      {
        return this->bottom_;
      }

      void MediumArea::
      bottom (const bottom_type& bottom)
      {
        this->bottom_.set (bottom);
      }

      void MediumArea::
      bottom (const bottom_optional& bottom)
      {
        this->bottom_ = bottom;
      }

      void MediumArea::
      bottom (::std::auto_ptr< bottom_type > bottom)
      {
        this->bottom_.set (bottom);
      }

      const MediumArea::left_optional& MediumArea::
      left () const
      {
        return this->left_;
      }

      MediumArea::left_optional& MediumArea::
      left ()
      {
        return this->left_;
      }

      void MediumArea::
      left (const left_type& left)
      {
        this->left_.set (left);
      }

      void MediumArea::
      left (const left_optional& left)
      {
        this->left_ = left;
      }

      void MediumArea::
      left (::std::auto_ptr< left_type > left)
      {
        this->left_.set (left);
      }

      const MediumArea::right_optional& MediumArea::
      right () const
      {
        return this->right_;
      }

      MediumArea::right_optional& MediumArea::
      right ()
      {
        return this->right_;
      }

      void MediumArea::
      right (const right_type& right)
      {
        this->right_.set (right);
      }

      void MediumArea::
      right (const right_optional& right)
      {
        this->right_ = right;
      }

      void MediumArea::
      right (::std::auto_ptr< right_type > right)
      {
        this->right_.set (right);
      }

      const MediumArea::from_optional& MediumArea::
      from () const
      {
        return this->from_;
      }

      MediumArea::from_optional& MediumArea::
      from ()
      {
        return this->from_;
      }

      void MediumArea::
      from (const from_type& from)
      {
        this->from_.set (from);
      }

      void MediumArea::
      from (const from_optional& from)
      {
        this->from_ = from;
      }

      void MediumArea::
      from (::std::auto_ptr< from_type > from)
      {
        this->from_.set (from);
      }

      const MediumArea::to_optional& MediumArea::
      to () const
      {
        return this->to_;
      }

      MediumArea::to_optional& MediumArea::
      to ()
      {
        return this->to_;
      }

      void MediumArea::
      to (const to_type& to)
      {
        this->to_.set (to);
      }

      void MediumArea::
      to (const to_optional& to)
      {
        this->to_ = to;
      }

      void MediumArea::
      to (::std::auto_ptr< to_type > to)
      {
        this->to_.set (to);
      }


      // Bound
      // 

      const Bound::substance_sequence& Bound::
      substance () const
      {
        return this->substance_;
      }

      Bound::substance_sequence& Bound::
      substance ()
      {
        return this->substance_;
      }

      void Bound::
      substance (const substance_sequence& substance)
      {
        this->substance_ = substance;
      }

      const Bound::name_optional& Bound::
      name () const
      {
        return this->name_;
      }

      Bound::name_optional& Bound::
      name ()
      {
        return this->name_;
      }

      void Bound::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void Bound::
      name (const name_optional& name)
      {
        this->name_ = name;
      }

      void Bound::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }

      const Bound::from_optional& Bound::
      from () const
      {
        return this->from_;
      }

      Bound::from_optional& Bound::
      from ()
      {
        return this->from_;
      }

      void Bound::
      from (const from_type& from)
      {
        this->from_.set (from);
      }

      void Bound::
      from (const from_optional& from)
      {
        this->from_ = from;
      }

      void Bound::
      from (::std::auto_ptr< from_type > from)
      {
        this->from_.set (from);
      }

      const Bound::to_optional& Bound::
      to () const
      {
        return this->to_;
      }

      Bound::to_optional& Bound::
      to ()
      {
        return this->to_;
      }

      void Bound::
      to (const to_type& to)
      {
        this->to_.set (to);
      }

      void Bound::
      to (const to_optional& to)
      {
        this->to_ = to;
      }

      void Bound::
      to (::std::auto_ptr< to_type > to)
      {
        this->to_.set (to);
      }

      const Bound::at_type& Bound::
      at () const
      {
        return this->at_.get ();
      }

      Bound::at_type& Bound::
      at ()
      {
        return this->at_.get ();
      }

      void Bound::
      at (const at_type& at)
      {
        this->at_.set (at);
      }

      void Bound::
      at (::std::auto_ptr< at_type > at)
      {
        this->at_.set (at);
      }


      // BoundSubstance
      // 

      const BoundSubstance::name_type& BoundSubstance::
      name () const
      {
        return this->name_.get ();
      }

      BoundSubstance::name_type& BoundSubstance::
      name ()
      {
        return this->name_.get ();
      }

      void BoundSubstance::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void BoundSubstance::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }


      // Transducer
      // 

      const Transducer::name_type& Transducer::
      name () const
      {
        return this->name_.get ();
      }

      Transducer::name_type& Transducer::
      name ()
      {
        return this->name_.get ();
      }

      void Transducer::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void Transducer::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }


      // Symbol
      // 

      const Symbol::name_type& Symbol::
      name () const
      {
        return this->name_.get ();
      }

      Symbol::name_type& Symbol::
      name ()
      {
        return this->name_.get ();
      }

      void Symbol::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void Symbol::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }

      const Symbol::value_type& Symbol::
      value () const
      {
        return this->value_.get ();
      }

      Symbol::value_type& Symbol::
      value ()
      {
        return this->value_.get ();
      }

      void Symbol::
      value (const value_type& value)
      {
        this->value_.set (value);
      }

      const Symbol::dimension_optional& Symbol::
      dimension () const
      {
        return this->dimension_;
      }

      Symbol::dimension_optional& Symbol::
      dimension ()
      {
        return this->dimension_;
      }

      void Symbol::
      dimension (const dimension_type& dimension)
      {
        this->dimension_.set (dimension);
      }

      void Symbol::
      dimension (const dimension_optional& dimension)
      {
        this->dimension_ = dimension;
      }

      void Symbol::
      dimension (::std::auto_ptr< dimension_type > dimension)
      {
        this->dimension_.set (dimension);
      }


      // Solver
      // 

      const Solver::output_sequence& Solver::
      output () const
      {
        return this->output_;
      }

      Solver::output_sequence& Solver::
      output ()
      {
        return this->output_;
      }

      void Solver::
      output (const output_sequence& output)
      {
        this->output_ = output;
      }


      // SolverOutput
      // 

      const SolverOutput::name_type& SolverOutput::
      name () const
      {
        return this->name_.get ();
      }

      SolverOutput::name_type& SolverOutput::
      name ()
      {
        return this->name_.get ();
      }

      void SolverOutput::
      name (const name_type& name)
      {
        this->name_.set (name);
      }

      void SolverOutput::
      name (::std::auto_ptr< name_type > name)
      {
        this->name_.set (name);
      }


      // CoordinateSystem
      // 

      CoordinateSystem::
      CoordinateSystem (value v)
      : ::xml_schema::string (_xsd_CoordinateSystem_literals_[v])
      {
      }

      CoordinateSystem::
      CoordinateSystem (const ::xml_schema::string& v)
      : ::xml_schema::string (v)
      {
      }

      CoordinateSystem::
      CoordinateSystem (const CoordinateSystem& v,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
      : ::xml_schema::string (v, f, c)
      {
      }

      CoordinateSystem& CoordinateSystem::
      operator= (value v)
      {
        static_cast< ::xml_schema::string& > (*this) = 
        ::xml_schema::string (_xsd_CoordinateSystem_literals_[v]);

        return *this;
      }


      // SubstanceName
      // 


      // MediumName
      // 


      // AxisName
      // 


      // BoundName
      // 


      // TransducerName
      // 


      // SymbolName
      // 
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace bio
{
  namespace xml
  {
    namespace model
    {
      // Model
      //

      Model::
      Model (const solver_type& solver,
             const coordinateSystem_type& coordinateSystem)
      : ::xml_schema::type (),
        axis_ (::xml_schema::flags (), this),
        substance_ (::xml_schema::flags (), this),
        medium_ (::xml_schema::flags (), this),
        bound_ (::xml_schema::flags (), this),
        transducer_ (::xml_schema::flags (), this),
        symbol_ (::xml_schema::flags (), this),
        solver_ (solver, ::xml_schema::flags (), this),
        coordinateSystem_ (coordinateSystem, ::xml_schema::flags (), this)
      {
      }

      Model::
      Model (const Model& x,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        axis_ (x.axis_, f, this),
        substance_ (x.substance_, f, this),
        medium_ (x.medium_, f, this),
        bound_ (x.bound_, f, this),
        transducer_ (x.transducer_, f, this),
        symbol_ (x.symbol_, f, this),
        solver_ (x.solver_, f, this),
        coordinateSystem_ (x.coordinateSystem_, f, this)
      {
      }

      Model::
      Model (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        axis_ (f, this),
        substance_ (f, this),
        medium_ (f, this),
        bound_ (f, this),
        transducer_ (f, this),
        symbol_ (f, this),
        solver_ (f, this),
        coordinateSystem_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Model::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // axis
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "axis",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< axis_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< axis_type > r (
                dynamic_cast< axis_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->axis ().push_back (r);
              continue;
            }
          }

          // substance
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "substance",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< substance_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< substance_type > r (
                dynamic_cast< substance_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->substance ().push_back (r);
              continue;
            }
          }

          // medium
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "medium",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< medium_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< medium_type > r (
                dynamic_cast< medium_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->medium ().push_back (r);
              continue;
            }
          }

          // bound
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "bound",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< bound_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< bound_type > r (
                dynamic_cast< bound_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->bound ().push_back (r);
              continue;
            }
          }

          // transducer
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "transducer",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< transducer_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              if (!this->transducer ())
              {
                ::std::auto_ptr< transducer_type > r (
                  dynamic_cast< transducer_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->transducer (r);
                continue;
              }
            }
          }

          // symbol
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "symbol",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< symbol_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< symbol_type > r (
                dynamic_cast< symbol_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->symbol ().push_back (r);
              continue;
            }
          }

          // solver
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "solver",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< solver_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              if (!solver_.present ())
              {
                ::std::auto_ptr< solver_type > r (
                  dynamic_cast< solver_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->solver (r);
                continue;
              }
            }
          }

          break;
        }

        if (!solver_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "solver",
            "http://lt.5grupe.karolis/biosensor/model");
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "coordinateSystem" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< coordinateSystem_type > r (
              coordinateSystem_traits::create (i, f, this));

            this->coordinateSystem (r);
            continue;
          }
        }

        if (!coordinateSystem_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "coordinateSystem",
            "");
        }
      }

      Model* Model::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Model (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Model >
      _xsd_Model_type_factory_init (
        "Model",
        "http://lt.5grupe.karolis/biosensor/model");


      // Axis
      //

      Axis::
      Axis (const name_type& name)
      : ::xml_schema::type (),
        point_ (::xml_schema::flags (), this),
        name_ (name, ::xml_schema::flags (), this)
      {
      }

      Axis::
      Axis (const Axis& x,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        point_ (x.point_, f, this),
        name_ (x.name_, f, this)
      {
      }

      Axis::
      Axis (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        point_ (f, this),
        name_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Axis::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // point
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "point",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< point_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< point_type > r (
                dynamic_cast< point_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->point ().push_back (r);
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }
      }

      Axis* Axis::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Axis (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Axis >
      _xsd_Axis_type_factory_init (
        "Axis",
        "http://lt.5grupe.karolis/biosensor/model");


      // AxisPoint
      //

      AxisPoint::
      AxisPoint (const position_type& position)
      : ::xml_schema::type (),
        position_ (position, ::xml_schema::flags (), this)
      {
      }

      AxisPoint::
      AxisPoint (const AxisPoint& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        position_ (x.position_, f, this)
      {
      }

      AxisPoint::
      AxisPoint (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        position_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void AxisPoint::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "position" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< position_type > r (
              position_traits::create (i, f, this));

            this->position (r);
            continue;
          }
        }

        if (!position_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "position",
            "");
        }
      }

      AxisPoint* AxisPoint::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new AxisPoint (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, AxisPoint >
      _xsd_AxisPoint_type_factory_init (
        "AxisPoint",
        "http://lt.5grupe.karolis/biosensor/model");


      // Substance
      //

      Substance::
      Substance (const name_type& name)
      : ::xml_schema::type (),
        name_ (name, ::xml_schema::flags (), this)
      {
      }

      Substance::
      Substance (const Substance& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this)
      {
      }

      Substance::
      Substance (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Substance::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }
      }

      Substance* Substance::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Substance (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Substance >
      _xsd_Substance_type_factory_init (
        "Substance",
        "http://lt.5grupe.karolis/biosensor/model");


      // Medium
      //

      Medium::
      Medium (const name_type& name)
      : ::xml_schema::type (),
        substance_ (::xml_schema::flags (), this),
        reaction_ (::xml_schema::flags (), this),
        area_ (::xml_schema::flags (), this),
        name_ (name, ::xml_schema::flags (), this)
      {
      }

      Medium::
      Medium (const Medium& x,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        substance_ (x.substance_, f, this),
        reaction_ (x.reaction_, f, this),
        area_ (x.area_, f, this),
        name_ (x.name_, f, this)
      {
      }

      Medium::
      Medium (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        substance_ (f, this),
        reaction_ (f, this),
        area_ (f, this),
        name_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Medium::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // substance
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "substance",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< substance_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< substance_type > r (
                dynamic_cast< substance_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->substance ().push_back (r);
              continue;
            }
          }

          // reaction
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "reaction",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< reaction_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< reaction_type > r (
                dynamic_cast< reaction_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->reaction ().push_back (r);
              continue;
            }
          }

          // area
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "area",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< area_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< area_type > r (
                dynamic_cast< area_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->area ().push_back (r);
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }
      }

      Medium* Medium::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Medium (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Medium >
      _xsd_Medium_type_factory_init (
        "Medium",
        "http://lt.5grupe.karolis/biosensor/model");


      // MediumSubstance
      //

      MediumSubstance::
      MediumSubstance (const name_type& name,
                       const initial_type& initial)
      : ::xml_schema::type (),
        name_ (name, ::xml_schema::flags (), this),
        diffusion_ (::xml_schema::flags (), this),
        initial_ (initial, ::xml_schema::flags (), this)
      {
      }

      MediumSubstance::
      MediumSubstance (const MediumSubstance& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this),
        diffusion_ (x.diffusion_, f, this),
        initial_ (x.initial_, f, this)
      {
      }

      MediumSubstance::
      MediumSubstance (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (f, this),
        diffusion_ (f, this),
        initial_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void MediumSubstance::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }

          if (n.name () == "diffusion" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< diffusion_type > r (
              diffusion_traits::create (i, f, this));

            this->diffusion (r);
            continue;
          }

          if (n.name () == "initial" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< initial_type > r (
              initial_traits::create (i, f, this));

            this->initial (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }

        if (!initial_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "initial",
            "");
        }
      }

      MediumSubstance* MediumSubstance::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new MediumSubstance (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, MediumSubstance >
      _xsd_MediumSubstance_type_factory_init (
        "MediumSubstance",
        "http://lt.5grupe.karolis/biosensor/model");


      // MediumReaction
      //

      MediumReaction::
      MediumReaction ()
      : ::xml_schema::type ()
      {
      }

      MediumReaction::
      MediumReaction (const MediumReaction& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c)
      {
      }

      MediumReaction::
      MediumReaction (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (e, f, c)
      {
      }

      MediumReaction::
      MediumReaction (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (a, f, c)
      {
      }

      MediumReaction::
      MediumReaction (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (s, e, f, c)
      {
      }

      MediumReaction* MediumReaction::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new MediumReaction (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, MediumReaction >
      _xsd_MediumReaction_type_factory_init (
        "MediumReaction",
        "http://lt.5grupe.karolis/biosensor/model");


      // MediumArea
      //

      MediumArea::
      MediumArea ()
      : ::xml_schema::type (),
        top_ (::xml_schema::flags (), this),
        bottom_ (::xml_schema::flags (), this),
        left_ (::xml_schema::flags (), this),
        right_ (::xml_schema::flags (), this),
        from_ (::xml_schema::flags (), this),
        to_ (::xml_schema::flags (), this)
      {
      }

      MediumArea::
      MediumArea (const MediumArea& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        top_ (x.top_, f, this),
        bottom_ (x.bottom_, f, this),
        left_ (x.left_, f, this),
        right_ (x.right_, f, this),
        from_ (x.from_, f, this),
        to_ (x.to_, f, this)
      {
      }

      MediumArea::
      MediumArea (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        top_ (f, this),
        bottom_ (f, this),
        left_ (f, this),
        right_ (f, this),
        from_ (f, this),
        to_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void MediumArea::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "top" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< top_type > r (
              top_traits::create (i, f, this));

            this->top (r);
            continue;
          }

          if (n.name () == "bottom" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< bottom_type > r (
              bottom_traits::create (i, f, this));

            this->bottom (r);
            continue;
          }

          if (n.name () == "left" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< left_type > r (
              left_traits::create (i, f, this));

            this->left (r);
            continue;
          }

          if (n.name () == "right" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< right_type > r (
              right_traits::create (i, f, this));

            this->right (r);
            continue;
          }

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< from_type > r (
              from_traits::create (i, f, this));

            this->from (r);
            continue;
          }

          if (n.name () == "to" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< to_type > r (
              to_traits::create (i, f, this));

            this->to (r);
            continue;
          }
        }
      }

      MediumArea* MediumArea::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new MediumArea (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, MediumArea >
      _xsd_MediumArea_type_factory_init (
        "MediumArea",
        "http://lt.5grupe.karolis/biosensor/model");


      // Bound
      //

      Bound::
      Bound (const at_type& at)
      : ::xml_schema::type (),
        substance_ (::xml_schema::flags (), this),
        name_ (::xml_schema::flags (), this),
        from_ (::xml_schema::flags (), this),
        to_ (::xml_schema::flags (), this),
        at_ (at, ::xml_schema::flags (), this)
      {
      }

      Bound::
      Bound (const Bound& x,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        substance_ (x.substance_, f, this),
        name_ (x.name_, f, this),
        from_ (x.from_, f, this),
        to_ (x.to_, f, this),
        at_ (x.at_, f, this)
      {
      }

      Bound::
      Bound (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        substance_ (f, this),
        name_ (f, this),
        from_ (f, this),
        to_ (f, this),
        at_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Bound::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // substance
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "substance",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< substance_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< substance_type > r (
                dynamic_cast< substance_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->substance ().push_back (r);
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< from_type > r (
              from_traits::create (i, f, this));

            this->from (r);
            continue;
          }

          if (n.name () == "to" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< to_type > r (
              to_traits::create (i, f, this));

            this->to (r);
            continue;
          }

          if (n.name () == "at" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< at_type > r (
              at_traits::create (i, f, this));

            this->at (r);
            continue;
          }
        }

        if (!at_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "at",
            "");
        }
      }

      Bound* Bound::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Bound (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Bound >
      _xsd_Bound_type_factory_init (
        "Bound",
        "http://lt.5grupe.karolis/biosensor/model");


      // BoundSubstance
      //

      BoundSubstance::
      BoundSubstance (const name_type& name)
      : ::xml_schema::type (),
        name_ (name, ::xml_schema::flags (), this)
      {
      }

      BoundSubstance::
      BoundSubstance (const BoundSubstance& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this)
      {
      }

      BoundSubstance::
      BoundSubstance (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void BoundSubstance::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }
      }

      BoundSubstance* BoundSubstance::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new BoundSubstance (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, BoundSubstance >
      _xsd_BoundSubstance_type_factory_init (
        "BoundSubstance",
        "http://lt.5grupe.karolis/biosensor/model");


      // Transducer
      //

      Transducer::
      Transducer (const name_type& name)
      : ::xml_schema::type (),
        name_ (name, ::xml_schema::flags (), this)
      {
      }

      Transducer::
      Transducer (const Transducer& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this)
      {
      }

      Transducer::
      Transducer (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Transducer::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }
      }

      Transducer* Transducer::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Transducer (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Transducer >
      _xsd_Transducer_type_factory_init (
        "Transducer",
        "http://lt.5grupe.karolis/biosensor/model");


      // Symbol
      //

      Symbol::
      Symbol (const name_type& name,
              const value_type& value)
      : ::xml_schema::type (),
        name_ (name, ::xml_schema::flags (), this),
        value_ (value, ::xml_schema::flags (), this),
        dimension_ (::xml_schema::flags (), this)
      {
      }

      Symbol::
      Symbol (const Symbol& x,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this),
        value_ (x.value_, f, this),
        dimension_ (x.dimension_, f, this)
      {
      }

      Symbol::
      Symbol (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (f, this),
        value_ (f, this),
        dimension_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Symbol::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }

          if (n.name () == "value" && n.namespace_ ().empty ())
          {
            this->value (value_traits::create (i, f, this));
            continue;
          }

          if (n.name () == "dimension" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< dimension_type > r (
              dimension_traits::create (i, f, this));

            this->dimension (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }

        if (!value_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "value",
            "");
        }
      }

      Symbol* Symbol::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Symbol (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Symbol >
      _xsd_Symbol_type_factory_init (
        "Symbol",
        "http://lt.5grupe.karolis/biosensor/model");


      // Solver
      //

      Solver::
      Solver ()
      : ::xml_schema::type (),
        output_ (::xml_schema::flags (), this)
      {
      }

      Solver::
      Solver (const Solver& x,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        output_ (x.output_, f, this)
      {
      }

      Solver::
      Solver (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        output_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void Solver::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        for (; p.more_elements (); p.next_element ())
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // output
          //
          {
            ::xsd::cxx::tree::type_factory_map< char >& tfm (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

            ::std::auto_ptr< ::xml_schema::type > tmp (
              tfm.create (
                "output",
                "http://lt.5grupe.karolis/biosensor/model",
                &::xsd::cxx::tree::factory_impl< output_type >,
                false, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              ::std::auto_ptr< output_type > r (
                dynamic_cast< output_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->output ().push_back (r);
              continue;
            }
          }

          break;
        }
      }

      Solver* Solver::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new Solver (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, Solver >
      _xsd_Solver_type_factory_init (
        "Solver",
        "http://lt.5grupe.karolis/biosensor/model");


      // SolverOutput
      //

      SolverOutput::
      SolverOutput (const name_type& name)
      : ::xml_schema::type (),
        name_ (name, ::xml_schema::flags (), this)
      {
      }

      SolverOutput::
      SolverOutput (const SolverOutput& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (x, f, c),
        name_ (x.name_, f, this)
      {
      }

      SolverOutput::
      SolverOutput (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
      : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
        name_ (f, this)
      {
        if ((f & ::xml_schema::flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e);
          this->parse (p, f);
        }
      }

      void SolverOutput::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::auto_ptr< name_type > r (
              name_traits::create (i, f, this));

            this->name (r);
            continue;
          }
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "name",
            "");
        }
      }

      SolverOutput* SolverOutput::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new SolverOutput (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, SolverOutput >
      _xsd_SolverOutput_type_factory_init (
        "SolverOutput",
        "http://lt.5grupe.karolis/biosensor/model");


      // CoordinateSystem
      //

      CoordinateSystem::
      CoordinateSystem (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
      : ::xml_schema::string (e, f, c)
      {
        _xsd_CoordinateSystem_convert ();
      }

      CoordinateSystem::
      CoordinateSystem (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
      : ::xml_schema::string (a, f, c)
      {
        _xsd_CoordinateSystem_convert ();
      }

      CoordinateSystem::
      CoordinateSystem (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
      : ::xml_schema::string (s, e, f, c)
      {
        _xsd_CoordinateSystem_convert ();
      }

      CoordinateSystem* CoordinateSystem::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new CoordinateSystem (*this, f, c);
      }

      CoordinateSystem::value CoordinateSystem::
      _xsd_CoordinateSystem_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CoordinateSystem_literals_);
        const value* i (::std::lower_bound (
                          _xsd_CoordinateSystem_indexes_,
                          _xsd_CoordinateSystem_indexes_ + 3,
                          *this,
                          c));

        if (i == _xsd_CoordinateSystem_indexes_ + 3 || _xsd_CoordinateSystem_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const CoordinateSystem::
      _xsd_CoordinateSystem_literals_[3] =
      {
        "Cartesian",
        "Cylindrical",
        "Linear"
      };

      const CoordinateSystem::value CoordinateSystem::
      _xsd_CoordinateSystem_indexes_[3] =
      {
        ::bio::xml::model::CoordinateSystem::Cartesian,
        ::bio::xml::model::CoordinateSystem::Cylindrical,
        ::bio::xml::model::CoordinateSystem::Linear
      };

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, CoordinateSystem >
      _xsd_CoordinateSystem_type_factory_init (
        "CoordinateSystem",
        "http://lt.5grupe.karolis/biosensor/model");


      // SubstanceName
      //

      SubstanceName::
      SubstanceName ()
      : ::xml_schema::string ()
      {
      }

      SubstanceName::
      SubstanceName (const ::xml_schema::string& string)
      : ::xml_schema::string (string)
      {
      }

      SubstanceName::
      SubstanceName (const SubstanceName& x,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
      : ::xml_schema::string (x, f, c)
      {
      }

      SubstanceName::
      SubstanceName (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
      : ::xml_schema::string (e, f, c)
      {
      }

      SubstanceName::
      SubstanceName (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
      : ::xml_schema::string (a, f, c)
      {
      }

      SubstanceName::
      SubstanceName (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
      : ::xml_schema::string (s, e, f, c)
      {
      }

      SubstanceName* SubstanceName::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new SubstanceName (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, SubstanceName >
      _xsd_SubstanceName_type_factory_init (
        "SubstanceName",
        "http://lt.5grupe.karolis/biosensor/model");


      // MediumName
      //

      MediumName::
      MediumName ()
      : ::xml_schema::string ()
      {
      }

      MediumName::
      MediumName (const ::xml_schema::string& string)
      : ::xml_schema::string (string)
      {
      }

      MediumName::
      MediumName (const MediumName& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (x, f, c)
      {
      }

      MediumName::
      MediumName (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (e, f, c)
      {
      }

      MediumName::
      MediumName (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (a, f, c)
      {
      }

      MediumName::
      MediumName (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (s, e, f, c)
      {
      }

      MediumName* MediumName::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new MediumName (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, MediumName >
      _xsd_MediumName_type_factory_init (
        "MediumName",
        "http://lt.5grupe.karolis/biosensor/model");


      // AxisName
      //

      AxisName::
      AxisName ()
      : ::xml_schema::string ()
      {
      }

      AxisName::
      AxisName (const ::xml_schema::string& string)
      : ::xml_schema::string (string)
      {
      }

      AxisName::
      AxisName (const AxisName& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::string (x, f, c)
      {
      }

      AxisName::
      AxisName (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::string (e, f, c)
      {
      }

      AxisName::
      AxisName (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::string (a, f, c)
      {
      }

      AxisName::
      AxisName (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
      : ::xml_schema::string (s, e, f, c)
      {
      }

      AxisName* AxisName::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new AxisName (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, AxisName >
      _xsd_AxisName_type_factory_init (
        "AxisName",
        "http://lt.5grupe.karolis/biosensor/model");


      // BoundName
      //

      BoundName::
      BoundName ()
      : ::xml_schema::string ()
      {
      }

      BoundName::
      BoundName (const ::xml_schema::string& string)
      : ::xml_schema::string (string)
      {
      }

      BoundName::
      BoundName (const BoundName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::string (x, f, c)
      {
      }

      BoundName::
      BoundName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::string (e, f, c)
      {
      }

      BoundName::
      BoundName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::string (a, f, c)
      {
      }

      BoundName::
      BoundName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
      : ::xml_schema::string (s, e, f, c)
      {
      }

      BoundName* BoundName::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new BoundName (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, BoundName >
      _xsd_BoundName_type_factory_init (
        "BoundName",
        "http://lt.5grupe.karolis/biosensor/model");


      // TransducerName
      //

      TransducerName::
      TransducerName ()
      : ::xml_schema::string ()
      {
      }

      TransducerName::
      TransducerName (const ::xml_schema::string& string)
      : ::xml_schema::string (string)
      {
      }

      TransducerName::
      TransducerName (const TransducerName& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::string (x, f, c)
      {
      }

      TransducerName::
      TransducerName (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::string (e, f, c)
      {
      }

      TransducerName::
      TransducerName (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::string (a, f, c)
      {
      }

      TransducerName::
      TransducerName (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
      : ::xml_schema::string (s, e, f, c)
      {
      }

      TransducerName* TransducerName::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new TransducerName (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, TransducerName >
      _xsd_TransducerName_type_factory_init (
        "TransducerName",
        "http://lt.5grupe.karolis/biosensor/model");


      // SymbolName
      //

      SymbolName::
      SymbolName ()
      : ::xml_schema::string ()
      {
      }

      SymbolName::
      SymbolName (const ::xml_schema::string& string)
      : ::xml_schema::string (string)
      {
      }

      SymbolName::
      SymbolName (const SymbolName& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (x, f, c)
      {
      }

      SymbolName::
      SymbolName (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (e, f, c)
      {
      }

      SymbolName::
      SymbolName (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (a, f, c)
      {
      }

      SymbolName::
      SymbolName (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
      : ::xml_schema::string (s, e, f, c)
      {
      }

      SymbolName* SymbolName::
      _clone (::xml_schema::flags f,
              ::xml_schema::type* c) const
      {
        return new SymbolName (*this, f, c);
      }

      static
      ::xsd::cxx::tree::type_factory_initializer< 0, char, SymbolName >
      _xsd_SymbolName_type_factory_init (
        "SymbolName",
        "http://lt.5grupe.karolis/biosensor/model");
    }
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace bio
{
  namespace xml
  {
    namespace model
    {
      ::std::auto_ptr< ::bio::xml::model::Model >
      model (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        ::std::auto_ptr< ::bio::xml::model::Model > r (
          ::bio::xml::model::model (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< char > ();

        ::std::auto_ptr< ::bio::xml::model::Model > r (
          ::bio::xml::model::model (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< char > ();

        ::std::auto_ptr< ::bio::xml::model::Model > r (
          ::bio::xml::model::model (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::bio::xml::model::model (wrap, f, p);
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::bio::xml::model::model (wrap, h, f, p);
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::bio::xml::model::model (wrap, h, f, p);
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::bio::xml::model::model (wrap, f, p);
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0,
          (f & ::xml_schema::flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::bio::xml::model::model (wrap, h, f, p);
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        ::xercesc::Wrapper4InputSource wrap (&isrc, false);
        return ::bio::xml::model::model (wrap, h, f, p);
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        ::std::auto_ptr< ::bio::xml::model::Model > r (
          ::bio::xml::model::model (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (const ::xercesc::DOMInputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< char > ();

        ::std::auto_ptr< ::bio::xml::model::Model > r (
          ::bio::xml::model::model (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

        if (!d)
          throw ::xsd::cxx::tree::parsing< char > ();

        ::std::auto_ptr< ::bio::xml::model::Model > r (
          ::bio::xml::model::model (
            d.get (), f | ::xml_schema::flags::own_dom, p));

        if (f & ::xml_schema::flags::keep_dom)
          d.release ();

        return r;
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
      {
        if (f & ::xml_schema::flags::keep_dom)
        {
          ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
            static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

          ::std::auto_ptr< ::bio::xml::model::Model > r (
            ::bio::xml::model::model (
              c.get (), f | ::xml_schema::flags::own_dom, p));

          c.release ();
          return r;
        }

        const ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xml_schema::type > tmp (
          tfm.create (
            "model",
            "http://lt.5grupe.karolis/biosensor/model",
            &::xsd::cxx::tree::factory_impl< ::bio::xml::model::Model >,
            true, true, e, n, f, 0));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< ::bio::xml::model::Model > r (
            dynamic_cast< ::bio::xml::model::Model* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "model",
          "http://lt.5grupe.karolis/biosensor/model");
      }

      ::std::auto_ptr< ::bio::xml::model::Model >
      model (::xercesc::DOMDocument* d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::flags::keep_dom) &&
           !(f & ::xml_schema::flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        const ::xercesc::DOMElement& e (
          c.get ()
          ? *c->getDocumentElement ()
          : *d->getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xml_schema::type > tmp (
          tfm.create (
            "model",
            "http://lt.5grupe.karolis/biosensor/model",
            &::xsd::cxx::tree::factory_impl< ::bio::xml::model::Model >,
            true, true, e, n, f, 0));

        if (tmp.get () != 0)
        {
          c.release ();

          ::std::auto_ptr< ::bio::xml::model::Model > r (
            dynamic_cast< ::bio::xml::model::Model* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "model",
          "http://lt.5grupe.karolis/biosensor/model");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace bio
{
  namespace xml
  {
    namespace model
    {
      void
      model (::std::ostream& o,
             const ::bio::xml::model::Model& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::bio::xml::model::model (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      model (::std::ostream& o,
             const ::bio::xml::model::Model& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::string& e,
             ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::flags::dont_initialize) == 0);

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::bio::xml::model::model (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      model (::std::ostream& o,
             const ::bio::xml::model::Model& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::string& e,
             ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::bio::xml::model::model (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      model (::xercesc::XMLFormatTarget& t,
             const ::bio::xml::model::Model& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::bio::xml::model::model (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      model (::xercesc::XMLFormatTarget& t,
             const ::bio::xml::model::Model& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::string& e,
             ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::bio::xml::model::model (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      model (::xercesc::XMLFormatTarget& t,
             const ::bio::xml::model::Model& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::string& e,
             ::xml_schema::flags f)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::bio::xml::model::model (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      model (::xercesc::DOMDocument& d,
             const ::bio::xml::model::Model& s,
             ::xml_schema::flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (typeid (::bio::xml::model::Model) == typeid (s))
        {
          if (n.name () == "model" &&
              n.namespace_ () == "http://lt.5grupe.karolis/biosensor/model")
          {
            e << s;
          }
          else
          {
            throw ::xsd::cxx::tree::unexpected_element < char > (
              n.name (),
              n.namespace_ (),
              "model",
              "http://lt.5grupe.karolis/biosensor/model");
          }
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          tsm.serialize (
            "model",
            "http://lt.5grupe.karolis/biosensor/model",
            e, n, s);
        }
      }

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
      model (const ::bio::xml::model::Model& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
      {
        try
        {
          ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

          if (typeid (::bio::xml::model::Model) == typeid (s))
          {
            d = ::xsd::cxx::xml::dom::serialize< char > (
              "model",
              "http://lt.5grupe.karolis/biosensor/model",
              m, f);
          }
          else
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            d = tsm.serialize (
              "model",
              "http://lt.5grupe.karolis/biosensor/model",
              m, s, f);
          }

          ::bio::xml::model::model (*d, s, f);
          return d;
        }
        catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
        {
          throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
        }
        catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
        {
          throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Model& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // axis
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Model::axis_const_iterator
               b (i.axis ().begin ()), n (i.axis ().end ());
               b != n; ++b)
          {
            if (typeid (Model::axis_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "axis",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "axis",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // substance
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Model::substance_const_iterator
               b (i.substance ().begin ()), n (i.substance ().end ());
               b != n; ++b)
          {
            if (typeid (Model::substance_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "substance",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "substance",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // medium
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Model::medium_const_iterator
               b (i.medium ().begin ()), n (i.medium ().end ());
               b != n; ++b)
          {
            if (typeid (Model::medium_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "medium",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "medium",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // bound
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Model::bound_const_iterator
               b (i.bound ().begin ()), n (i.bound ().end ());
               b != n; ++b)
          {
            if (typeid (Model::bound_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "bound",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "bound",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // transducer
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          if (i.transducer ())
          {
            const Model::transducer_type& x (*i.transducer ());
            if (typeid (Model::transducer_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "transducer",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "transducer",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, x);
          }
        }

        // symbol
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Model::symbol_const_iterator
               b (i.symbol ().begin ()), n (i.symbol ().end ());
               b != n; ++b)
          {
            if (typeid (Model::symbol_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "symbol",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "symbol",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // solver
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          const Model::solver_type& x (i.solver ());
          if (typeid (Model::solver_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "solver",
                "http://lt.5grupe.karolis/biosensor/model",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "solver",
              "http://lt.5grupe.karolis/biosensor/model",
              false, true, e, x);
        }

        // coordinateSystem
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "coordinateSystem",
              e));

          a << i.coordinateSystem ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Model >
      _xsd_Model_type_serializer_init (
        "Model",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const Axis& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // point
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Axis::point_const_iterator
               b (i.point ().begin ()), n (i.point ().end ());
               b != n; ++b)
          {
            if (typeid (Axis::point_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "point",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "point",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Axis >
      _xsd_Axis_type_serializer_init (
        "Axis",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const AxisPoint& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // position
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "position",
              e));

          a << i.position ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, AxisPoint >
      _xsd_AxisPoint_type_serializer_init (
        "AxisPoint",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const Substance& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Substance >
      _xsd_Substance_type_serializer_init (
        "Substance",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const Medium& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // substance
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Medium::substance_const_iterator
               b (i.substance ().begin ()), n (i.substance ().end ());
               b != n; ++b)
          {
            if (typeid (Medium::substance_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "substance",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "substance",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // reaction
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Medium::reaction_const_iterator
               b (i.reaction ().begin ()), n (i.reaction ().end ());
               b != n; ++b)
          {
            if (typeid (Medium::reaction_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "reaction",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "reaction",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // area
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Medium::area_const_iterator
               b (i.area ().begin ()), n (i.area ().end ());
               b != n; ++b)
          {
            if (typeid (Medium::area_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "area",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "area",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Medium >
      _xsd_Medium_type_serializer_init (
        "Medium",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const MediumSubstance& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }

        // diffusion
        //
        if (i.diffusion ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "diffusion",
              e));

          a << *i.diffusion ();
        }

        // initial
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "initial",
              e));

          a << i.initial ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, MediumSubstance >
      _xsd_MediumSubstance_type_serializer_init (
        "MediumSubstance",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const MediumReaction& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr&,const MediumReaction&)
      {
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >&,
                  const MediumReaction&)
      {
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, MediumReaction >
      _xsd_MediumReaction_type_serializer_init (
        "MediumReaction",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const MediumArea& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // top
        //
        if (i.top ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "top",
              e));

          a << *i.top ();
        }

        // bottom
        //
        if (i.bottom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "bottom",
              e));

          a << *i.bottom ();
        }

        // left
        //
        if (i.left ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "left",
              e));

          a << *i.left ();
        }

        // right
        //
        if (i.right ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "right",
              e));

          a << *i.right ();
        }

        // from
        //
        if (i.from ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.from ();
        }

        // to
        //
        if (i.to ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "to",
              e));

          a << *i.to ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, MediumArea >
      _xsd_MediumArea_type_serializer_init (
        "MediumArea",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const Bound& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // substance
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Bound::substance_const_iterator
               b (i.substance ().begin ()), n (i.substance ().end ());
               b != n; ++b)
          {
            if (typeid (Bound::substance_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "substance",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "substance",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }

        // name
        //
        if (i.name ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << *i.name ();
        }

        // from
        //
        if (i.from ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.from ();
        }

        // to
        //
        if (i.to ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "to",
              e));

          a << *i.to ();
        }

        // at
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "at",
              e));

          a << i.at ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Bound >
      _xsd_Bound_type_serializer_init (
        "Bound",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const BoundSubstance& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, BoundSubstance >
      _xsd_BoundSubstance_type_serializer_init (
        "BoundSubstance",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const Transducer& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Transducer >
      _xsd_Transducer_type_serializer_init (
        "Transducer",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const Symbol& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }

        // value
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "value",
              e));

          a << i.value ();
        }

        // dimension
        //
        if (i.dimension ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "dimension",
              e));

          a << *i.dimension ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Symbol >
      _xsd_Symbol_type_serializer_init (
        "Symbol",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const Solver& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // output
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          for (Solver::output_const_iterator
               b (i.output ().begin ()), n (i.output ().end ());
               b != n; ++b)
          {
            if (typeid (Solver::output_type) == typeid (*b))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "output",
                  "http://lt.5grupe.karolis/biosensor/model",
                  e));

              s << *b;
            }
            else
              tsm.serialize (
                "output",
                "http://lt.5grupe.karolis/biosensor/model",
                false, true, e, *b);
          }
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, Solver >
      _xsd_Solver_type_serializer_init (
        "Solver",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const SolverOutput& i)
      {
        e << static_cast< const ::xml_schema::type& > (i);

        // name
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "name",
              e));

          a << i.name ();
        }
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, SolverOutput >
      _xsd_SolverOutput_type_serializer_init (
        "SolverOutput",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const CoordinateSystem& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const CoordinateSystem& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >& l,
                  const CoordinateSystem& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, CoordinateSystem >
      _xsd_CoordinateSystem_type_serializer_init (
        "CoordinateSystem",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const SubstanceName& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const SubstanceName& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >& l,
                  const SubstanceName& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, SubstanceName >
      _xsd_SubstanceName_type_serializer_init (
        "SubstanceName",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const MediumName& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const MediumName& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >& l,
                  const MediumName& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, MediumName >
      _xsd_MediumName_type_serializer_init (
        "MediumName",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const AxisName& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const AxisName& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >& l,
                  const AxisName& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, AxisName >
      _xsd_AxisName_type_serializer_init (
        "AxisName",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const BoundName& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const BoundName& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >& l,
                  const BoundName& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, BoundName >
      _xsd_BoundName_type_serializer_init (
        "BoundName",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const TransducerName& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const TransducerName& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >& l,
                  const TransducerName& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransducerName >
      _xsd_TransducerName_type_serializer_init (
        "TransducerName",
        "http://lt.5grupe.karolis/biosensor/model");


      void
      operator<< (::xercesc::DOMElement& e, const SymbolName& i)
      {
        e << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a,const SymbolName& i)
      {
        a << static_cast< const ::xml_schema::string& > (i);
      }

      void
      operator<< (::xsd::cxx::tree::list_stream< char >& l,
                  const SymbolName& i)
      {
        l << static_cast< const ::xml_schema::string& > (i);
      }

      static
      ::xsd::cxx::tree::type_serializer_initializer< 0, char, SymbolName >
      _xsd_SymbolName_type_serializer_init (
        "SymbolName",
        "http://lt.5grupe.karolis/biosensor/model");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

