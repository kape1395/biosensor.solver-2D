// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ModelSolver.hxx"

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
        // FiniteDifferences
        // 

        const FiniteDifferences::axis_sequence& FiniteDifferences::
        axis () const
        {
          return this->axis_;
        }

        FiniteDifferences::axis_sequence& FiniteDifferences::
        axis ()
        {
          return this->axis_;
        }

        void FiniteDifferences::
        axis (const axis_sequence& axis)
        {
          this->axis_ = axis;
        }

        const FiniteDifferences::stopCondition_sequence& FiniteDifferences::
        stopCondition () const
        {
          return this->stopCondition_;
        }

        FiniteDifferences::stopCondition_sequence& FiniteDifferences::
        stopCondition ()
        {
          return this->stopCondition_;
        }

        void FiniteDifferences::
        stopCondition (const stopCondition_sequence& stopCondition)
        {
          this->stopCondition_ = stopCondition;
        }

        const FiniteDifferences::timeStepAdjuster_optional& FiniteDifferences::
        timeStepAdjuster () const
        {
          return this->timeStepAdjuster_;
        }

        FiniteDifferences::timeStepAdjuster_optional& FiniteDifferences::
        timeStepAdjuster ()
        {
          return this->timeStepAdjuster_;
        }

        void FiniteDifferences::
        timeStepAdjuster (const timeStepAdjuster_type& timeStepAdjuster)
        {
          this->timeStepAdjuster_.set (timeStepAdjuster);
        }

        void FiniteDifferences::
        timeStepAdjuster (const timeStepAdjuster_optional& timeStepAdjuster)
        {
          this->timeStepAdjuster_ = timeStepAdjuster;
        }

        void FiniteDifferences::
        timeStepAdjuster (::std::auto_ptr< timeStepAdjuster_type > timeStepAdjuster)
        {
          this->timeStepAdjuster_.set (timeStepAdjuster);
        }

        const FiniteDifferences::timeStep_type& FiniteDifferences::
        timeStep () const
        {
          return this->timeStep_.get ();
        }

        FiniteDifferences::timeStep_type& FiniteDifferences::
        timeStep ()
        {
          return this->timeStep_.get ();
        }

        void FiniteDifferences::
        timeStep (const timeStep_type& timeStep)
        {
          this->timeStep_.set (timeStep);
        }


        // Explicit1D
        // 


        // Implicit1D
        // 


        // Explicit2D
        // 


        // Implicit2D
        // 


        // Axis
        // 

        const Axis::from_type& Axis::
        from () const
        {
          return this->from_.get ();
        }

        Axis::from_type& Axis::
        from ()
        {
          return this->from_.get ();
        }

        void Axis::
        from (const from_type& from)
        {
          this->from_.set (from);
        }

        void Axis::
        from (::std::auto_ptr< from_type > from)
        {
          this->from_.set (from);
        }

        const Axis::to_type& Axis::
        to () const
        {
          return this->to_.get ();
        }

        Axis::to_type& Axis::
        to ()
        {
          return this->to_.get ();
        }

        void Axis::
        to (const to_type& to)
        {
          this->to_.set (to);
        }

        void Axis::
        to (::std::auto_ptr< to_type > to)
        {
          this->to_.set (to);
        }


        // ConstantAxisPart
        // 

        const ConstantAxisPart::stepCount_type& ConstantAxisPart::
        stepCount () const
        {
          return this->stepCount_.get ();
        }

        ConstantAxisPart::stepCount_type& ConstantAxisPart::
        stepCount ()
        {
          return this->stepCount_.get ();
        }

        void ConstantAxisPart::
        stepCount (const stepCount_type& stepCount)
        {
          this->stepCount_.set (stepCount);
        }


        // BilinearAxisPart
        // 

        const BilinearAxisPart::startStep_type& BilinearAxisPart::
        startStep () const
        {
          return this->startStep_.get ();
        }

        BilinearAxisPart::startStep_type& BilinearAxisPart::
        startStep ()
        {
          return this->startStep_.get ();
        }

        void BilinearAxisPart::
        startStep (const startStep_type& startStep)
        {
          this->startStep_.set (startStep);
        }

        const BilinearAxisPart::factor_type& BilinearAxisPart::
        factor () const
        {
          return this->factor_.get ();
        }

        BilinearAxisPart::factor_type& BilinearAxisPart::
        factor ()
        {
          return this->factor_.get ();
        }

        void BilinearAxisPart::
        factor (const factor_type& factor)
        {
          this->factor_.set (factor);
        }


        // ConcentrationProfile
        // 


        // CurrentDensity
        // 


        // AveragedConcentration
        // 

        const AveragedConcentration::medium_optional& AveragedConcentration::
        medium () const
        {
          return this->medium_;
        }

        AveragedConcentration::medium_optional& AveragedConcentration::
        medium ()
        {
          return this->medium_;
        }

        void AveragedConcentration::
        medium (const medium_type& medium)
        {
          this->medium_.set (medium);
        }

        void AveragedConcentration::
        medium (const medium_optional& medium)
        {
          this->medium_ = medium;
        }

        void AveragedConcentration::
        medium (::std::auto_ptr< medium_type > medium)
        {
          this->medium_.set (medium);
        }


        // SteadyStateHalfTime
        // 


        // SteadyState
        // 

        const SteadyState::output_sequence& SteadyState::
        output () const
        {
          return this->output_;
        }

        SteadyState::output_sequence& SteadyState::
        output ()
        {
          return this->output_;
        }

        void SteadyState::
        output (const output_sequence& output)
        {
          this->output_ = output;
        }


        // Kinetic
        // 

        const Kinetic::output_sequence& Kinetic::
        output () const
        {
          return this->output_;
        }

        Kinetic::output_sequence& Kinetic::
        output ()
        {
          return this->output_;
        }

        void Kinetic::
        output (const output_sequence& output)
        {
          this->output_ = output;
        }

        const Kinetic::stepCount_optional& Kinetic::
        stepCount () const
        {
          return this->stepCount_;
        }

        Kinetic::stepCount_optional& Kinetic::
        stepCount ()
        {
          return this->stepCount_;
        }

        void Kinetic::
        stepCount (const stepCount_type& stepCount)
        {
          this->stepCount_.set (stepCount);
        }

        void Kinetic::
        stepCount (const stepCount_optional& stepCount)
        {
          this->stepCount_ = stepCount;
        }

        const Kinetic::time_optional& Kinetic::
        time () const
        {
          return this->time_;
        }

        Kinetic::time_optional& Kinetic::
        time ()
        {
          return this->time_;
        }

        void Kinetic::
        time (const time_type& time)
        {
          this->time_.set (time);
        }

        void Kinetic::
        time (const time_optional& time)
        {
          this->time_ = time;
        }


        // StopCondition
        // 


        // StopConditionValidAfter
        // 

        const StopConditionValidAfter::stopCondition_sequence& StopConditionValidAfter::
        stopCondition () const
        {
          return this->stopCondition_;
        }

        StopConditionValidAfter::stopCondition_sequence& StopConditionValidAfter::
        stopCondition ()
        {
          return this->stopCondition_;
        }

        void StopConditionValidAfter::
        stopCondition (const stopCondition_sequence& stopCondition)
        {
          this->stopCondition_ = stopCondition;
        }

        const StopConditionValidAfter::stepCount_optional& StopConditionValidAfter::
        stepCount () const
        {
          return this->stepCount_;
        }

        StopConditionValidAfter::stepCount_optional& StopConditionValidAfter::
        stepCount ()
        {
          return this->stepCount_;
        }

        void StopConditionValidAfter::
        stepCount (const stepCount_type& stepCount)
        {
          this->stepCount_.set (stepCount);
        }

        void StopConditionValidAfter::
        stepCount (const stepCount_optional& stepCount)
        {
          this->stepCount_ = stepCount;
        }

        const StopConditionValidAfter::time_optional& StopConditionValidAfter::
        time () const
        {
          return this->time_;
        }

        StopConditionValidAfter::time_optional& StopConditionValidAfter::
        time ()
        {
          return this->time_;
        }

        void StopConditionValidAfter::
        time (const time_type& time)
        {
          this->time_.set (time);
        }

        void StopConditionValidAfter::
        time (const time_optional& time)
        {
          this->time_ = time;
        }


        // FailIfAbove
        // 

        const FailIfAbove::stepCount_optional& FailIfAbove::
        stepCount () const
        {
          return this->stepCount_;
        }

        FailIfAbove::stepCount_optional& FailIfAbove::
        stepCount ()
        {
          return this->stepCount_;
        }

        void FailIfAbove::
        stepCount (const stepCount_type& stepCount)
        {
          this->stepCount_.set (stepCount);
        }

        void FailIfAbove::
        stepCount (const stepCount_optional& stepCount)
        {
          this->stepCount_ = stepCount;
        }

        const FailIfAbove::time_optional& FailIfAbove::
        time () const
        {
          return this->time_;
        }

        FailIfAbove::time_optional& FailIfAbove::
        time ()
        {
          return this->time_;
        }

        void FailIfAbove::
        time (const time_type& time)
        {
          this->time_.set (time);
        }

        void FailIfAbove::
        time (const time_optional& time)
        {
          this->time_ = time;
        }


        // FailIfInvalidConcentrations
        // 


        // FailISumOfConcentrationsNonConst
        // 

        const FailISumOfConcentrationsNonConst::substance_sequence& FailISumOfConcentrationsNonConst::
        substance () const
        {
          return this->substance_;
        }

        FailISumOfConcentrationsNonConst::substance_sequence& FailISumOfConcentrationsNonConst::
        substance ()
        {
          return this->substance_;
        }

        void FailISumOfConcentrationsNonConst::
        substance (const substance_sequence& substance)
        {
          this->substance_ = substance;
        }

        const FailISumOfConcentrationsNonConst::medium_type& FailISumOfConcentrationsNonConst::
        medium () const
        {
          return this->medium_.get ();
        }

        FailISumOfConcentrationsNonConst::medium_type& FailISumOfConcentrationsNonConst::
        medium ()
        {
          return this->medium_.get ();
        }

        void FailISumOfConcentrationsNonConst::
        medium (const medium_type& medium)
        {
          this->medium_.set (medium);
        }

        void FailISumOfConcentrationsNonConst::
        medium (::std::auto_ptr< medium_type > medium)
        {
          this->medium_.set (medium);
        }

        const FailISumOfConcentrationsNonConst::sum_type& FailISumOfConcentrationsNonConst::
        sum () const
        {
          return this->sum_.get ();
        }

        FailISumOfConcentrationsNonConst::sum_type& FailISumOfConcentrationsNonConst::
        sum ()
        {
          return this->sum_.get ();
        }

        void FailISumOfConcentrationsNonConst::
        sum (const sum_type& sum)
        {
          this->sum_.set (sum);
        }

        void FailISumOfConcentrationsNonConst::
        sum (::std::auto_ptr< sum_type > sum)
        {
          this->sum_.set (sum);
        }

        const FailISumOfConcentrationsNonConst::error_type& FailISumOfConcentrationsNonConst::
        error () const
        {
          return this->error_.get ();
        }

        FailISumOfConcentrationsNonConst::error_type& FailISumOfConcentrationsNonConst::
        error ()
        {
          return this->error_.get ();
        }

        void FailISumOfConcentrationsNonConst::
        error (const error_type& error)
        {
          this->error_.set (error);
        }


        // CurrentDensityGradient
        // 

        const CurrentDensityGradient::lessThan_type& CurrentDensityGradient::
        lessThan () const
        {
          return this->lessThan_.get ();
        }

        CurrentDensityGradient::lessThan_type& CurrentDensityGradient::
        lessThan ()
        {
          return this->lessThan_.get ();
        }

        void CurrentDensityGradient::
        lessThan (const lessThan_type& lessThan)
        {
          this->lessThan_.set (lessThan);
        }

        const CurrentDensityGradient::normalized_type& CurrentDensityGradient::
        normalized () const
        {
          return this->normalized_.get ();
        }

        CurrentDensityGradient::normalized_type& CurrentDensityGradient::
        normalized ()
        {
          return this->normalized_.get ();
        }

        void CurrentDensityGradient::
        normalized (const normalized_type& normalized)
        {
          this->normalized_.set (normalized);
        }


        // TimeStepAdjuster
        // 


        // SimpleTimeStepAdjuster
        // 

        const SimpleTimeStepAdjuster::factor_type& SimpleTimeStepAdjuster::
        factor () const
        {
          return this->factor_.get ();
        }

        SimpleTimeStepAdjuster::factor_type& SimpleTimeStepAdjuster::
        factor ()
        {
          return this->factor_.get ();
        }

        void SimpleTimeStepAdjuster::
        factor (const factor_type& factor)
        {
          this->factor_.set (factor);
        }

        const SimpleTimeStepAdjuster::everyStepCount_type& SimpleTimeStepAdjuster::
        everyStepCount () const
        {
          return this->everyStepCount_.get ();
        }

        SimpleTimeStepAdjuster::everyStepCount_type& SimpleTimeStepAdjuster::
        everyStepCount ()
        {
          return this->everyStepCount_.get ();
        }

        void SimpleTimeStepAdjuster::
        everyStepCount (const everyStepCount_type& everyStepCount)
        {
          this->everyStepCount_.set (everyStepCount);
        }

        const SimpleTimeStepAdjuster::maxStepSize_optional& SimpleTimeStepAdjuster::
        maxStepSize () const
        {
          return this->maxStepSize_;
        }

        SimpleTimeStepAdjuster::maxStepSize_optional& SimpleTimeStepAdjuster::
        maxStepSize ()
        {
          return this->maxStepSize_;
        }

        void SimpleTimeStepAdjuster::
        maxStepSize (const maxStepSize_type& maxStepSize)
        {
          this->maxStepSize_.set (maxStepSize);
        }

        void SimpleTimeStepAdjuster::
        maxStepSize (const maxStepSize_optional& maxStepSize)
        {
          this->maxStepSize_ = maxStepSize;
        }
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
        // FiniteDifferences
        //

        FiniteDifferences::
        FiniteDifferences (const timeStep_type& timeStep)
        : ::bio::xml::model::Solver (),
          axis_ (::xml_schema::flags (), this),
          stopCondition_ (::xml_schema::flags (), this),
          timeStepAdjuster_ (::xml_schema::flags (), this),
          timeStep_ (timeStep, ::xml_schema::flags (), this)
        {
        }

        FiniteDifferences::
        FiniteDifferences (const FiniteDifferences& x,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
        : ::bio::xml::model::Solver (x, f, c),
          axis_ (x.axis_, f, this),
          stopCondition_ (x.stopCondition_, f, this),
          timeStepAdjuster_ (x.timeStepAdjuster_, f, this),
          timeStep_ (x.timeStep_, f, this)
        {
        }

        FiniteDifferences::
        FiniteDifferences (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
        : ::bio::xml::model::Solver (e, f | ::xml_schema::flags::base, c),
          axis_ (f, this),
          stopCondition_ (f, this),
          timeStepAdjuster_ (f, this),
          timeStep_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void FiniteDifferences::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::Solver::parse (p, f);

          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // axis
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xml_schema::type > tmp (
                tfm.create (
                  "axis",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< axis_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< axis_type > r (
                  dynamic_cast< axis_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->axis ().push_back (r);
                continue;
              }
            }

            // stopCondition
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xml_schema::type > tmp (
                tfm.create (
                  "stopCondition",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< stopCondition_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< stopCondition_type > r (
                  dynamic_cast< stopCondition_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->stopCondition ().push_back (r);
                continue;
              }
            }

            // timeStepAdjuster
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xml_schema::type > tmp (
                tfm.create (
                  "timeStepAdjuster",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< timeStepAdjuster_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->timeStepAdjuster ())
                {
                  ::std::auto_ptr< timeStepAdjuster_type > r (
                    dynamic_cast< timeStepAdjuster_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->timeStepAdjuster (r);
                  continue;
                }
              }
            }

            break;
          }

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "timeStep" && n.namespace_ ().empty ())
            {
              this->timeStep (timeStep_traits::create (i, f, this));
              continue;
            }
          }

          if (!timeStep_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "timeStep",
              "");
          }
        }

        FiniteDifferences* FiniteDifferences::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new FiniteDifferences (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, FiniteDifferences >
        _xsd_FiniteDifferences_type_factory_init (
          "FiniteDifferences",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // Explicit1D
        //

        Explicit1D::
        Explicit1D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Explicit1D::
        Explicit1D (const Explicit1D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Explicit1D::
        Explicit1D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Explicit1D* Explicit1D::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new Explicit1D (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, Explicit1D >
        _xsd_Explicit1D_type_factory_init (
          "Explicit1D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // Implicit1D
        //

        Implicit1D::
        Implicit1D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Implicit1D::
        Implicit1D (const Implicit1D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Implicit1D::
        Implicit1D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Implicit1D* Implicit1D::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new Implicit1D (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, Implicit1D >
        _xsd_Implicit1D_type_factory_init (
          "Implicit1D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // Explicit2D
        //

        Explicit2D::
        Explicit2D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Explicit2D::
        Explicit2D (const Explicit2D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Explicit2D::
        Explicit2D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Explicit2D* Explicit2D::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new Explicit2D (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, Explicit2D >
        _xsd_Explicit2D_type_factory_init (
          "Explicit2D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // Implicit2D
        //

        Implicit2D::
        Implicit2D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Implicit2D::
        Implicit2D (const Implicit2D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Implicit2D::
        Implicit2D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Implicit2D* Implicit2D::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new Implicit2D (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, Implicit2D >
        _xsd_Implicit2D_type_factory_init (
          "Implicit2D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // Axis
        //

        Axis::
        Axis (const from_type& from,
              const to_type& to)
        : ::xml_schema::type (),
          from_ (from, ::xml_schema::flags (), this),
          to_ (to, ::xml_schema::flags (), this)
        {
        }

        Axis::
        Axis (const Axis& x,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
        : ::xml_schema::type (x, f, c),
          from_ (x.from_, f, this),
          to_ (x.to_, f, this)
        {
        }

        Axis::
        Axis (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
        : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
          from_ (f, this),
          to_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void Axis::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "from" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< from_type > r (
                from_traits::create (i, f, this));

              this->from (r);
              continue;
            }

            if (n.name () == "to" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< to_type > r (
                to_traits::create (i, f, this));

              this->to (r);
              continue;
            }
          }

          if (!from_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "from",
              "");
          }

          if (!to_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "to",
              "");
          }
        }

        Axis* Axis::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new Axis (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, Axis >
        _xsd_Axis_type_factory_init (
          "Axis",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // ConstantAxisPart
        //

        ConstantAxisPart::
        ConstantAxisPart (const from_type& from,
                          const to_type& to,
                          const stepCount_type& stepCount)
        : ::bio::xml::model::solver::Axis (from,
                                           to),
          stepCount_ (stepCount, ::xml_schema::flags (), this)
        {
        }

        ConstantAxisPart::
        ConstantAxisPart (const ConstantAxisPart& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::bio::xml::model::solver::Axis (x, f, c),
          stepCount_ (x.stepCount_, f, this)
        {
        }

        ConstantAxisPart::
        ConstantAxisPart (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::bio::xml::model::solver::Axis (e, f | ::xml_schema::flags::base, c),
          stepCount_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void ConstantAxisPart::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::solver::Axis::parse (p, f);

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount (stepCount_traits::create (i, f, this));
              continue;
            }
          }

          if (!stepCount_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "stepCount",
              "");
          }
        }

        ConstantAxisPart* ConstantAxisPart::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new ConstantAxisPart (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, ConstantAxisPart >
        _xsd_ConstantAxisPart_type_factory_init (
          "ConstantAxisPart",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // BilinearAxisPart
        //

        BilinearAxisPart::
        BilinearAxisPart (const from_type& from,
                          const to_type& to,
                          const startStep_type& startStep,
                          const factor_type& factor)
        : ::bio::xml::model::solver::Axis (from,
                                           to),
          startStep_ (startStep, ::xml_schema::flags (), this),
          factor_ (factor, ::xml_schema::flags (), this)
        {
        }

        BilinearAxisPart::
        BilinearAxisPart (const BilinearAxisPart& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::bio::xml::model::solver::Axis (x, f, c),
          startStep_ (x.startStep_, f, this),
          factor_ (x.factor_, f, this)
        {
        }

        BilinearAxisPart::
        BilinearAxisPart (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::bio::xml::model::solver::Axis (e, f | ::xml_schema::flags::base, c),
          startStep_ (f, this),
          factor_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void BilinearAxisPart::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::solver::Axis::parse (p, f);

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "startStep" && n.namespace_ ().empty ())
            {
              this->startStep (startStep_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "factor" && n.namespace_ ().empty ())
            {
              this->factor (factor_traits::create (i, f, this));
              continue;
            }
          }

          if (!startStep_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "startStep",
              "");
          }

          if (!factor_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "factor",
              "");
          }
        }

        BilinearAxisPart* BilinearAxisPart::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new BilinearAxisPart (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, BilinearAxisPart >
        _xsd_BilinearAxisPart_type_factory_init (
          "BilinearAxisPart",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // ConcentrationProfile
        //

        ConcentrationProfile::
        ConcentrationProfile (const name_type& name)
        : ::bio::xml::model::SolverOutput (name)
        {
        }

        ConcentrationProfile::
        ConcentrationProfile (const ConcentrationProfile& x,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (x, f, c)
        {
        }

        ConcentrationProfile::
        ConcentrationProfile (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (e, f, c)
        {
        }

        ConcentrationProfile* ConcentrationProfile::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new ConcentrationProfile (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, ConcentrationProfile >
        _xsd_ConcentrationProfile_type_factory_init (
          "ConcentrationProfile",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // CurrentDensity
        //

        CurrentDensity::
        CurrentDensity (const name_type& name)
        : ::bio::xml::model::SolverOutput (name)
        {
        }

        CurrentDensity::
        CurrentDensity (const CurrentDensity& x,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (x, f, c)
        {
        }

        CurrentDensity::
        CurrentDensity (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (e, f, c)
        {
        }

        CurrentDensity* CurrentDensity::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new CurrentDensity (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, CurrentDensity >
        _xsd_CurrentDensity_type_factory_init (
          "CurrentDensity",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // AveragedConcentration
        //

        AveragedConcentration::
        AveragedConcentration (const name_type& name)
        : ::bio::xml::model::SolverOutput (name),
          medium_ (::xml_schema::flags (), this)
        {
        }

        AveragedConcentration::
        AveragedConcentration (const AveragedConcentration& x,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (x, f, c),
          medium_ (x.medium_, f, this)
        {
        }

        AveragedConcentration::
        AveragedConcentration (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (e, f | ::xml_schema::flags::base, c),
          medium_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void AveragedConcentration::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::SolverOutput::parse (p, f);

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "medium" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< medium_type > r (
                medium_traits::create (i, f, this));

              this->medium (r);
              continue;
            }
          }
        }

        AveragedConcentration* AveragedConcentration::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new AveragedConcentration (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, AveragedConcentration >
        _xsd_AveragedConcentration_type_factory_init (
          "AveragedConcentration",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // SteadyStateHalfTime
        //

        SteadyStateHalfTime::
        SteadyStateHalfTime (const name_type& name)
        : ::bio::xml::model::SolverOutput (name)
        {
        }

        SteadyStateHalfTime::
        SteadyStateHalfTime (const SteadyStateHalfTime& x,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (x, f, c)
        {
        }

        SteadyStateHalfTime::
        SteadyStateHalfTime (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (e, f, c)
        {
        }

        SteadyStateHalfTime* SteadyStateHalfTime::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new SteadyStateHalfTime (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, SteadyStateHalfTime >
        _xsd_SteadyStateHalfTime_type_factory_init (
          "SteadyStateHalfTime",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // SteadyState
        //

        SteadyState::
        SteadyState (const name_type& name)
        : ::bio::xml::model::SolverOutput (name),
          output_ (::xml_schema::flags (), this)
        {
        }

        SteadyState::
        SteadyState (const SteadyState& x,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (x, f, c),
          output_ (x.output_, f, this)
        {
        }

        SteadyState::
        SteadyState (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (e, f | ::xml_schema::flags::base, c),
          output_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void SteadyState::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::SolverOutput::parse (p, f);

          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // output
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xml_schema::type > tmp (
                tfm.create (
                  "output",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< output_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< output_type > r (
                  dynamic_cast< output_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->output ().push_back (r);
                continue;
              }
            }

            break;
          }
        }

        SteadyState* SteadyState::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new SteadyState (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, SteadyState >
        _xsd_SteadyState_type_factory_init (
          "SteadyState",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // Kinetic
        //

        Kinetic::
        Kinetic (const name_type& name)
        : ::bio::xml::model::SolverOutput (name),
          output_ (::xml_schema::flags (), this),
          stepCount_ (::xml_schema::flags (), this),
          time_ (::xml_schema::flags (), this)
        {
        }

        Kinetic::
        Kinetic (const Kinetic& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (x, f, c),
          output_ (x.output_, f, this),
          stepCount_ (x.stepCount_, f, this),
          time_ (x.time_, f, this)
        {
        }

        Kinetic::
        Kinetic (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
        : ::bio::xml::model::SolverOutput (e, f | ::xml_schema::flags::base, c),
          output_ (f, this),
          stepCount_ (f, this),
          time_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void Kinetic::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::SolverOutput::parse (p, f);

          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // output
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xml_schema::type > tmp (
                tfm.create (
                  "output",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< output_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< output_type > r (
                  dynamic_cast< output_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->output ().push_back (r);
                continue;
              }
            }

            break;
          }

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount (stepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "time" && n.namespace_ ().empty ())
            {
              this->time (time_traits::create (i, f, this));
              continue;
            }
          }
        }

        Kinetic* Kinetic::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new Kinetic (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, Kinetic >
        _xsd_Kinetic_type_factory_init (
          "Kinetic",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // StopCondition
        //

        StopCondition::
        StopCondition ()
        : ::xml_schema::type ()
        {
        }

        StopCondition::
        StopCondition (const StopCondition& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
        : ::xml_schema::type (x, f, c)
        {
        }

        StopCondition::
        StopCondition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
        : ::xml_schema::type (e, f, c)
        {
        }

        StopCondition::
        StopCondition (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
        : ::xml_schema::type (a, f, c)
        {
        }

        StopCondition::
        StopCondition (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
        : ::xml_schema::type (s, e, f, c)
        {
        }

        StopCondition* StopCondition::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new StopCondition (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, StopCondition >
        _xsd_StopCondition_type_factory_init (
          "StopCondition",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // StopConditionValidAfter
        //

        StopConditionValidAfter::
        StopConditionValidAfter ()
        : ::bio::xml::model::solver::StopCondition (),
          stopCondition_ (::xml_schema::flags (), this),
          stepCount_ (::xml_schema::flags (), this),
          time_ (::xml_schema::flags (), this)
        {
        }

        StopConditionValidAfter::
        StopConditionValidAfter (const StopConditionValidAfter& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          stopCondition_ (x.stopCondition_, f, this),
          stepCount_ (x.stepCount_, f, this),
          time_ (x.time_, f, this)
        {
        }

        StopConditionValidAfter::
        StopConditionValidAfter (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          stopCondition_ (f, this),
          stepCount_ (f, this),
          time_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void StopConditionValidAfter::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // stopCondition
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xml_schema::type > tmp (
                tfm.create (
                  "stopCondition",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< stopCondition_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< stopCondition_type > r (
                  dynamic_cast< stopCondition_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->stopCondition ().push_back (r);
                continue;
              }
            }

            break;
          }

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount (stepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "time" && n.namespace_ ().empty ())
            {
              this->time (time_traits::create (i, f, this));
              continue;
            }
          }
        }

        StopConditionValidAfter* StopConditionValidAfter::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new StopConditionValidAfter (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, StopConditionValidAfter >
        _xsd_StopConditionValidAfter_type_factory_init (
          "StopConditionValidAfter",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // FailIfAbove
        //

        FailIfAbove::
        FailIfAbove ()
        : ::bio::xml::model::solver::StopCondition (),
          stepCount_ (::xml_schema::flags (), this),
          time_ (::xml_schema::flags (), this)
        {
        }

        FailIfAbove::
        FailIfAbove (const FailIfAbove& x,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          stepCount_ (x.stepCount_, f, this),
          time_ (x.time_, f, this)
        {
        }

        FailIfAbove::
        FailIfAbove (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          stepCount_ (f, this),
          time_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void FailIfAbove::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount (stepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "time" && n.namespace_ ().empty ())
            {
              this->time (time_traits::create (i, f, this));
              continue;
            }
          }
        }

        FailIfAbove* FailIfAbove::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new FailIfAbove (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, FailIfAbove >
        _xsd_FailIfAbove_type_factory_init (
          "FailIfAbove",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // FailIfInvalidConcentrations
        //

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations ()
        : ::bio::xml::model::solver::StopCondition ()
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const FailIfInvalidConcentrations& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c)
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (e, f, c)
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (a, f, c)
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (s, e, f, c)
        {
        }

        FailIfInvalidConcentrations* FailIfInvalidConcentrations::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new FailIfInvalidConcentrations (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, FailIfInvalidConcentrations >
        _xsd_FailIfInvalidConcentrations_type_factory_init (
          "FailIfInvalidConcentrations",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // FailISumOfConcentrationsNonConst
        //

        FailISumOfConcentrationsNonConst::
        FailISumOfConcentrationsNonConst (const medium_type& medium,
                                          const sum_type& sum,
                                          const error_type& error)
        : ::bio::xml::model::solver::StopCondition (),
          substance_ (::xml_schema::flags (), this),
          medium_ (medium, ::xml_schema::flags (), this),
          sum_ (sum, ::xml_schema::flags (), this),
          error_ (error, ::xml_schema::flags (), this)
        {
        }

        FailISumOfConcentrationsNonConst::
        FailISumOfConcentrationsNonConst (const FailISumOfConcentrationsNonConst& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          substance_ (x.substance_, f, this),
          medium_ (x.medium_, f, this),
          sum_ (x.sum_, f, this),
          error_ (x.error_, f, this)
        {
        }

        FailISumOfConcentrationsNonConst::
        FailISumOfConcentrationsNonConst (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          substance_ (f, this),
          medium_ (f, this),
          sum_ (f, this),
          error_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void FailISumOfConcentrationsNonConst::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // substance
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xml_schema::type > tmp (
                tfm.create (
                  "substance",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< substance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< substance_type > r (
                  dynamic_cast< substance_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->substance ().push_back (r);
                continue;
              }
            }

            break;
          }

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "medium" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< medium_type > r (
                medium_traits::create (i, f, this));

              this->medium (r);
              continue;
            }

            if (n.name () == "sum" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< sum_type > r (
                sum_traits::create (i, f, this));

              this->sum (r);
              continue;
            }

            if (n.name () == "error" && n.namespace_ ().empty ())
            {
              this->error (error_traits::create (i, f, this));
              continue;
            }
          }

          if (!medium_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "medium",
              "");
          }

          if (!sum_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "sum",
              "");
          }

          if (!error_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "error",
              "");
          }
        }

        FailISumOfConcentrationsNonConst* FailISumOfConcentrationsNonConst::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new FailISumOfConcentrationsNonConst (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, FailISumOfConcentrationsNonConst >
        _xsd_FailISumOfConcentrationsNonConst_type_factory_init (
          "FailISumOfConcentrationsNonConst",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // CurrentDensityGradient
        //

        CurrentDensityGradient::
        CurrentDensityGradient (const lessThan_type& lessThan,
                                const normalized_type& normalized)
        : ::bio::xml::model::solver::StopCondition (),
          lessThan_ (lessThan, ::xml_schema::flags (), this),
          normalized_ (normalized, ::xml_schema::flags (), this)
        {
        }

        CurrentDensityGradient::
        CurrentDensityGradient (const CurrentDensityGradient& x,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          lessThan_ (x.lessThan_, f, this),
          normalized_ (x.normalized_, f, this)
        {
        }

        CurrentDensityGradient::
        CurrentDensityGradient (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          lessThan_ (f, this),
          normalized_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void CurrentDensityGradient::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "lessThan" && n.namespace_ ().empty ())
            {
              this->lessThan (lessThan_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "normalized" && n.namespace_ ().empty ())
            {
              this->normalized (normalized_traits::create (i, f, this));
              continue;
            }
          }

          if (!lessThan_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "lessThan",
              "");
          }

          if (!normalized_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "normalized",
              "");
          }
        }

        CurrentDensityGradient* CurrentDensityGradient::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new CurrentDensityGradient (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, CurrentDensityGradient >
        _xsd_CurrentDensityGradient_type_factory_init (
          "CurrentDensityGradient",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // TimeStepAdjuster
        //

        TimeStepAdjuster::
        TimeStepAdjuster ()
        : ::xml_schema::type ()
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const TimeStepAdjuster& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::xml_schema::type (x, f, c)
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::xml_schema::type (e, f, c)
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::xml_schema::type (a, f, c)
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
        : ::xml_schema::type (s, e, f, c)
        {
        }

        TimeStepAdjuster* TimeStepAdjuster::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new TimeStepAdjuster (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, TimeStepAdjuster >
        _xsd_TimeStepAdjuster_type_factory_init (
          "TimeStepAdjuster",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        // SimpleTimeStepAdjuster
        //

        SimpleTimeStepAdjuster::
        SimpleTimeStepAdjuster (const factor_type& factor,
                                const everyStepCount_type& everyStepCount)
        : ::bio::xml::model::solver::TimeStepAdjuster (),
          factor_ (factor, ::xml_schema::flags (), this),
          everyStepCount_ (everyStepCount, ::xml_schema::flags (), this),
          maxStepSize_ (::xml_schema::flags (), this)
        {
        }

        SimpleTimeStepAdjuster::
        SimpleTimeStepAdjuster (const SimpleTimeStepAdjuster& x,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
        : ::bio::xml::model::solver::TimeStepAdjuster (x, f, c),
          factor_ (x.factor_, f, this),
          everyStepCount_ (x.everyStepCount_, f, this),
          maxStepSize_ (x.maxStepSize_, f, this)
        {
        }

        SimpleTimeStepAdjuster::
        SimpleTimeStepAdjuster (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
        : ::bio::xml::model::solver::TimeStepAdjuster (e, f | ::xml_schema::flags::base, c),
          factor_ (f, this),
          everyStepCount_ (f, this),
          maxStepSize_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e);
            this->parse (p, f);
          }
        }

        void SimpleTimeStepAdjuster::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "factor" && n.namespace_ ().empty ())
            {
              this->factor (factor_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "everyStepCount" && n.namespace_ ().empty ())
            {
              this->everyStepCount (everyStepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "maxStepSize" && n.namespace_ ().empty ())
            {
              this->maxStepSize (maxStepSize_traits::create (i, f, this));
              continue;
            }
          }

          if (!factor_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "factor",
              "");
          }

          if (!everyStepCount_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "everyStepCount",
              "");
          }
        }

        SimpleTimeStepAdjuster* SimpleTimeStepAdjuster::
        _clone (::xml_schema::flags f,
                ::xml_schema::type* c) const
        {
          return new SimpleTimeStepAdjuster (*this, f, c);
        }

        static
        ::xsd::cxx::tree::type_factory_initializer< 0, char, SimpleTimeStepAdjuster >
        _xsd_SimpleTimeStepAdjuster_type_factory_init (
          "SimpleTimeStepAdjuster",
          "http://lt.5grupe.karolis/biosensor/model/solver");
      }
    }
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
        void
        operator<< (::xercesc::DOMElement& e, const FiniteDifferences& i)
        {
          e << static_cast< const ::bio::xml::model::Solver& > (i);

          // axis
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FiniteDifferences::axis_const_iterator
                 b (i.axis ().begin ()), n (i.axis ().end ());
                 b != n; ++b)
            {
              if (typeid (FiniteDifferences::axis_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "axis",
                    "http://lt.5grupe.karolis/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "axis",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // stopCondition
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FiniteDifferences::stopCondition_const_iterator
                 b (i.stopCondition ().begin ()), n (i.stopCondition ().end ());
                 b != n; ++b)
            {
              if (typeid (FiniteDifferences::stopCondition_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "stopCondition",
                    "http://lt.5grupe.karolis/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "stopCondition",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // timeStepAdjuster
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.timeStepAdjuster ())
            {
              const FiniteDifferences::timeStepAdjuster_type& x (*i.timeStepAdjuster ());
              if (typeid (FiniteDifferences::timeStepAdjuster_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "timeStepAdjuster",
                    "http://lt.5grupe.karolis/biosensor/model/solver",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "timeStepAdjuster",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  false, true, e, x);
            }
          }

          // timeStep
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "timeStep",
                e));

            a << i.timeStep ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, FiniteDifferences >
        _xsd_FiniteDifferences_type_serializer_init (
          "FiniteDifferences",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Explicit1D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, Explicit1D >
        _xsd_Explicit1D_type_serializer_init (
          "Explicit1D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Implicit1D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, Implicit1D >
        _xsd_Implicit1D_type_serializer_init (
          "Implicit1D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Explicit2D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, Explicit2D >
        _xsd_Explicit2D_type_serializer_init (
          "Explicit2D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Implicit2D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, Implicit2D >
        _xsd_Implicit2D_type_serializer_init (
          "Implicit2D",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Axis& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);

          // from
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "from",
                e));

            a << i.from ();
          }

          // to
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "to",
                e));

            a << i.to ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, Axis >
        _xsd_Axis_type_serializer_init (
          "Axis",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const ConstantAxisPart& i)
        {
          e << static_cast< const ::bio::xml::model::solver::Axis& > (i);

          // stepCount
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << i.stepCount ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConstantAxisPart >
        _xsd_ConstantAxisPart_type_serializer_init (
          "ConstantAxisPart",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const BilinearAxisPart& i)
        {
          e << static_cast< const ::bio::xml::model::solver::Axis& > (i);

          // startStep
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "startStep",
                e));

            a << i.startStep ();
          }

          // factor
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "factor",
                e));

            a << i.factor ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, BilinearAxisPart >
        _xsd_BilinearAxisPart_type_serializer_init (
          "BilinearAxisPart",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const ConcentrationProfile& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConcentrationProfile >
        _xsd_ConcentrationProfile_type_serializer_init (
          "ConcentrationProfile",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const CurrentDensity& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, CurrentDensity >
        _xsd_CurrentDensity_type_serializer_init (
          "CurrentDensity",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const AveragedConcentration& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);

          // medium
          //
          if (i.medium ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "medium",
                e));

            a << *i.medium ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, AveragedConcentration >
        _xsd_AveragedConcentration_type_serializer_init (
          "AveragedConcentration",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const SteadyStateHalfTime& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, SteadyStateHalfTime >
        _xsd_SteadyStateHalfTime_type_serializer_init (
          "SteadyStateHalfTime",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const SteadyState& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);

          // output
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (SteadyState::output_const_iterator
                 b (i.output ().begin ()), n (i.output ().end ());
                 b != n; ++b)
            {
              if (typeid (SteadyState::output_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "output",
                    "http://lt.5grupe.karolis/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "output",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  false, true, e, *b);
            }
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, SteadyState >
        _xsd_SteadyState_type_serializer_init (
          "SteadyState",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Kinetic& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);

          // output
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (Kinetic::output_const_iterator
                 b (i.output ().begin ()), n (i.output ().end ());
                 b != n; ++b)
            {
              if (typeid (Kinetic::output_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "output",
                    "http://lt.5grupe.karolis/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "output",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // stepCount
          //
          if (i.stepCount ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << *i.stepCount ();
          }

          // time
          //
          if (i.time ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "time",
                e));

            a << *i.time ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, Kinetic >
        _xsd_Kinetic_type_serializer_init (
          "Kinetic",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const StopCondition& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr&,const StopCondition&)
        {
        }

        void
        operator<< (::xsd::cxx::tree::list_stream< char >&,
                    const StopCondition&)
        {
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopCondition >
        _xsd_StopCondition_type_serializer_init (
          "StopCondition",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const StopConditionValidAfter& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // stopCondition
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (StopConditionValidAfter::stopCondition_const_iterator
                 b (i.stopCondition ().begin ()), n (i.stopCondition ().end ());
                 b != n; ++b)
            {
              if (typeid (StopConditionValidAfter::stopCondition_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "stopCondition",
                    "http://lt.5grupe.karolis/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "stopCondition",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // stepCount
          //
          if (i.stepCount ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << *i.stepCount ();
          }

          // time
          //
          if (i.time ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "time",
                e));

            a << *i.time ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopConditionValidAfter >
        _xsd_StopConditionValidAfter_type_serializer_init (
          "StopConditionValidAfter",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const FailIfAbove& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // stepCount
          //
          if (i.stepCount ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << *i.stepCount ();
          }

          // time
          //
          if (i.time ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "time",
                e));

            a << *i.time ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailIfAbove >
        _xsd_FailIfAbove_type_serializer_init (
          "FailIfAbove",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const FailIfInvalidConcentrations& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a,const FailIfInvalidConcentrations& i)
        {
          a << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        void
        operator<< (::xsd::cxx::tree::list_stream< char >& l,
                    const FailIfInvalidConcentrations& i)
        {
          l << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailIfInvalidConcentrations >
        _xsd_FailIfInvalidConcentrations_type_serializer_init (
          "FailIfInvalidConcentrations",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const FailISumOfConcentrationsNonConst& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // substance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FailISumOfConcentrationsNonConst::substance_const_iterator
                 b (i.substance ().begin ()), n (i.substance ().end ());
                 b != n; ++b)
            {
              if (typeid (FailISumOfConcentrationsNonConst::substance_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "substance",
                    "http://lt.5grupe.karolis/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "substance",
                  "http://lt.5grupe.karolis/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // medium
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "medium",
                e));

            a << i.medium ();
          }

          // sum
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "sum",
                e));

            a << i.sum ();
          }

          // error
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "error",
                e));

            a << i.error ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailISumOfConcentrationsNonConst >
        _xsd_FailISumOfConcentrationsNonConst_type_serializer_init (
          "FailISumOfConcentrationsNonConst",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const CurrentDensityGradient& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // lessThan
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "lessThan",
                e));

            a << i.lessThan ();
          }

          // normalized
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "normalized",
                e));

            a << i.normalized ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, CurrentDensityGradient >
        _xsd_CurrentDensityGradient_type_serializer_init (
          "CurrentDensityGradient",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const TimeStepAdjuster& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr&,const TimeStepAdjuster&)
        {
        }

        void
        operator<< (::xsd::cxx::tree::list_stream< char >&,
                    const TimeStepAdjuster&)
        {
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimeStepAdjuster >
        _xsd_TimeStepAdjuster_type_serializer_init (
          "TimeStepAdjuster",
          "http://lt.5grupe.karolis/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const SimpleTimeStepAdjuster& i)
        {
          e << static_cast< const ::bio::xml::model::solver::TimeStepAdjuster& > (i);

          // factor
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "factor",
                e));

            a << i.factor ();
          }

          // everyStepCount
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "everyStepCount",
                e));

            a << i.everyStepCount ();
          }

          // maxStepSize
          //
          if (i.maxStepSize ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "maxStepSize",
                e));

            a << *i.maxStepSize ();
          }
        }

        static
        ::xsd::cxx::tree::type_serializer_initializer< 0, char, SimpleTimeStepAdjuster >
        _xsd_SimpleTimeStepAdjuster_type_serializer_init (
          "SimpleTimeStepAdjuster",
          "http://lt.5grupe.karolis/biosensor/model/solver");
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

